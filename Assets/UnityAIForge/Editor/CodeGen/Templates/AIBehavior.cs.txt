using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// AI behavior system with patrol, chase, flee, and attack states.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum AIBehaviorType
    {
        Patrol,
        Chase,
        Flee,
        PatrolAndChase
    }

    public enum PatrolMode
    {
        Loop,
        PingPong,
        Random
    }

    public enum AIState
    {
        Idle,
        Patrol,
        Chase,
        Attack,
        Flee,
        Return
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string aiId = "{{AI_ID}}";

    [Header("Behavior")]
    [SerializeField] private AIBehaviorType behaviorType = AIBehaviorType.{{BEHAVIOR_TYPE}};
    [SerializeField] private bool use2D = {{USE_2D}};

    [Header("Movement")]
    [SerializeField] private float moveSpeed = {{MOVE_SPEED}};
    [SerializeField] private float turnSpeed = {{TURN_SPEED}};

    [Header("Detection")]
    [SerializeField] private float detectionRadius = {{DETECTION_RADIUS}};
    [SerializeField] private float fieldOfView = {{FIELD_OF_VIEW}};
    [SerializeField] private bool requireLineOfSight = {{REQUIRE_LINE_OF_SIGHT}};
    [SerializeField] private float loseTargetDistance = {{LOSE_TARGET_DISTANCE}};
    [SerializeField] private string chaseTargetTag = "{{CHASE_TARGET_TAG}}";

    [Header("Patrol")]
    [SerializeField] private PatrolMode patrolMode = PatrolMode.{{PATROL_MODE}};
    [SerializeField] private List<Transform> patrolPoints = new List<Transform>();
    [SerializeField] private float waitTimeAtPoint = {{WAIT_TIME_AT_POINT}};
    [SerializeField] private float arrivalThreshold = 0.3f;

    [Header("Combat")]
    [SerializeField] private float attackRange = {{ATTACK_RANGE}};
    [SerializeField] private float attackCooldown = {{ATTACK_COOLDOWN}};

    [Header("Flee")]
    [SerializeField] private float fleeDistance = {{FLEE_DISTANCE}};

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<AIState, AIState> OnStateChanged = new UnityEvent<AIState, AIState>();
    public UnityEvent<GameObject> OnTargetDetected = new UnityEvent<GameObject>();
    public UnityEvent OnTargetLost = new UnityEvent();
    public UnityEvent<Transform> OnPatrolPointReached = new UnityEvent<Transform>();
    public UnityEvent OnAttack = new UnityEvent();

    #endregion

    #region State

    private AIState currentState = AIState.Idle;
    private Transform currentTarget;
    private int currentPatrolIndex;
    private int patrolDirection = 1;
    private float waitTimer;
    private float attackTimer;
    private Vector3 startPosition;

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var a) ? a : null;
    }

    #endregion

    #region Properties

    public string AIId => aiId;
    public AIState CurrentState => currentState;
    public Transform CurrentTarget => currentTarget;
    public AIBehaviorType BehaviorType => behaviorType;

    #endregion

    #region Lifecycle

    private void Awake()
    {
        startPosition = transform.position;
    }

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(aiId))
            _registry[aiId] = this;

        if (behaviorType == AIBehaviorType.Patrol || behaviorType == AIBehaviorType.PatrolAndChase)
            ChangeState(AIState.Patrol);
        else
            ChangeState(AIState.Idle);
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(aiId))
            _registry.Remove(aiId);
    }

    private void Update()
    {
        if (attackTimer > 0)
            attackTimer -= Time.deltaTime;

        switch (currentState)
        {
            case AIState.Idle:
                UpdateIdle();
                break;
            case AIState.Patrol:
                UpdatePatrol();
                break;
            case AIState.Chase:
                UpdateChase();
                break;
            case AIState.Attack:
                UpdateAttack();
                break;
            case AIState.Flee:
                UpdateFlee();
                break;
            case AIState.Return:
                UpdateReturn();
                break;
        }
    }

    #endregion

    #region Public API

    public void SetTarget(Transform target)
    {
        currentTarget = target;
        if (target != null)
        {
            OnTargetDetected?.Invoke(target.gameObject);
            if (behaviorType == AIBehaviorType.Flee)
                ChangeState(AIState.Flee);
            else
                ChangeState(AIState.Chase);
        }
    }

    public void ClearTarget()
    {
        currentTarget = null;
        OnTargetLost?.Invoke();
        if (behaviorType == AIBehaviorType.Patrol || behaviorType == AIBehaviorType.PatrolAndChase)
            ChangeState(AIState.Return);
        else
            ChangeState(AIState.Idle);
    }

    public void SetState(AIState state)
    {
        ChangeState(state);
    }

    public void AddPatrolPoint(Transform point)
    {
        if (point != null)
            patrolPoints.Add(point);
    }

    public void ClearPatrolPoints()
    {
        patrolPoints.Clear();
        currentPatrolIndex = 0;
    }

    #endregion

    #region State Updates

    private void UpdateIdle()
    {
        if (ShouldDetect())
            TryDetectTarget();
    }

    private void UpdatePatrol()
    {
        if (ShouldDetect())
            TryDetectTarget();

        if (patrolPoints.Count == 0) return;

        if (waitTimer > 0)
        {
            waitTimer -= Time.deltaTime;
            return;
        }

        var target = patrolPoints[currentPatrolIndex];
        if (target == null) { AdvancePatrolIndex(); return; }

        MoveTowards(target.position);

        if (GetDistance(target.position) < arrivalThreshold)
        {
            OnPatrolPointReached?.Invoke(target);
            waitTimer = waitTimeAtPoint;
            AdvancePatrolIndex();
        }
    }

    private void UpdateChase()
    {
        if (currentTarget == null)
        {
            ClearTarget();
            return;
        }

        float dist = GetDistance(currentTarget.position);

        if (dist > loseTargetDistance)
        {
            ClearTarget();
            return;
        }

        if (dist <= attackRange)
        {
            ChangeState(AIState.Attack);
            return;
        }

        MoveTowards(currentTarget.position);
    }

    private void UpdateAttack()
    {
        if (currentTarget == null)
        {
            ClearTarget();
            return;
        }

        float dist = GetDistance(currentTarget.position);

        if (dist > attackRange * 1.2f)
        {
            ChangeState(AIState.Chase);
            return;
        }

        LookAt(currentTarget.position);

        if (attackTimer <= 0)
        {
            OnAttack?.Invoke();
            gameObject.SendMessage("Attack", SendMessageOptions.DontRequireReceiver);
            attackTimer = attackCooldown;
        }
    }

    private void UpdateFlee()
    {
        if (currentTarget == null)
        {
            ChangeState(AIState.Return);
            return;
        }

        float dist = GetDistance(currentTarget.position);
        if (dist >= fleeDistance)
        {
            ClearTarget();
            return;
        }

        Vector3 fleeDir = (transform.position - currentTarget.position).normalized;
        MoveTowards(transform.position + fleeDir * moveSpeed);
    }

    private void UpdateReturn()
    {
        MoveTowards(startPosition);
        if (GetDistance(startPosition) < arrivalThreshold)
        {
            if (behaviorType == AIBehaviorType.Patrol || behaviorType == AIBehaviorType.PatrolAndChase)
                ChangeState(AIState.Patrol);
            else
                ChangeState(AIState.Idle);
        }
    }

    #endregion

    #region Internal

    private void ChangeState(AIState newState)
    {
        if (currentState == newState) return;
        var prev = currentState;
        currentState = newState;
        OnStateChanged?.Invoke(prev, newState);
    }

    private bool ShouldDetect()
    {
        return behaviorType == AIBehaviorType.Chase
            || behaviorType == AIBehaviorType.PatrolAndChase
            || behaviorType == AIBehaviorType.Flee;
    }

    private void TryDetectTarget()
    {
        if (currentTarget != null) return;

        var candidates = string.IsNullOrEmpty(chaseTargetTag)
            ? Object.FindObjectsByType<Transform>(FindObjectsSortMode.None)
            : null;

        GameObject[] tagged = string.IsNullOrEmpty(chaseTargetTag)
            ? null
            : GameObject.FindGameObjectsWithTag(chaseTargetTag);

        if (tagged != null)
        {
            float closestDist = float.MaxValue;
            Transform closest = null;

            foreach (var go in tagged)
            {
                if (go == gameObject) continue;
                float dist = GetDistance(go.transform.position);
                if (dist <= detectionRadius && dist < closestDist)
                {
                    if (IsInFieldOfView(go.transform.position))
                    {
                        if (!requireLineOfSight || HasLineOfSight(go.transform.position))
                        {
                            closestDist = dist;
                            closest = go.transform;
                        }
                    }
                }
            }

            if (closest != null)
                SetTarget(closest);
        }
    }

    private bool IsInFieldOfView(Vector3 targetPos)
    {
        if (fieldOfView >= 360f) return true;
        Vector3 dir = (targetPos - transform.position).normalized;
        Vector3 forward = use2D ? transform.right : transform.forward;
        float angle = Vector3.Angle(forward, dir);
        return angle <= fieldOfView * 0.5f;
    }

    private bool HasLineOfSight(Vector3 targetPos)
    {
        Vector3 dir = targetPos - transform.position;
        if (use2D)
        {
            var hit = Physics2D.Raycast(transform.position, dir.normalized, dir.magnitude);
            return hit.collider == null || hit.collider.gameObject.transform.position == targetPos;
        }
        else
        {
            return !Physics.Raycast(transform.position, dir.normalized, dir.magnitude);
        }
    }

    private void MoveTowards(Vector3 targetPos)
    {
        Vector3 dir;
        if (use2D)
            dir = new Vector3(targetPos.x - transform.position.x, targetPos.y - transform.position.y, 0).normalized;
        else
            dir = new Vector3(targetPos.x - transform.position.x, 0, targetPos.z - transform.position.z).normalized;

        var rb2d = GetComponent<Rigidbody2D>();
        var rb = GetComponent<Rigidbody>();

        if (rb2d != null)
        {
            rb2d.MovePosition(rb2d.position + (Vector2)dir * moveSpeed * Time.deltaTime);
        }
        else if (rb != null)
        {
            rb.MovePosition(rb.position + dir * moveSpeed * Time.deltaTime);
        }
        else
        {
            transform.position += dir * moveSpeed * Time.deltaTime;
        }

        LookAt(targetPos);
    }

    private void LookAt(Vector3 targetPos)
    {
        if (use2D)
        {
            Vector2 dir = (targetPos - transform.position).normalized;
            if (dir.sqrMagnitude > 0.001f)
            {
                float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
                transform.rotation = Quaternion.Lerp(transform.rotation,
                    Quaternion.Euler(0, 0, angle), turnSpeed * Time.deltaTime);
            }
        }
        else
        {
            Vector3 dir = new Vector3(targetPos.x - transform.position.x, 0, targetPos.z - transform.position.z);
            if (dir.sqrMagnitude > 0.001f)
            {
                Quaternion targetRot = Quaternion.LookRotation(dir);
                transform.rotation = Quaternion.Lerp(transform.rotation, targetRot, turnSpeed * Time.deltaTime);
            }
        }
    }

    private float GetDistance(Vector3 targetPos)
    {
        if (use2D)
            return Vector2.Distance(transform.position, targetPos);
        return Vector3.Distance(transform.position, targetPos);
    }

    private void AdvancePatrolIndex()
    {
        if (patrolPoints.Count == 0) return;

        switch (patrolMode)
        {
            case PatrolMode.Loop:
                currentPatrolIndex = (currentPatrolIndex + 1) % patrolPoints.Count;
                break;
            case PatrolMode.PingPong:
                currentPatrolIndex += patrolDirection;
                if (currentPatrolIndex >= patrolPoints.Count - 1 || currentPatrolIndex <= 0)
                    patrolDirection *= -1;
                currentPatrolIndex = Mathf.Clamp(currentPatrolIndex, 0, patrolPoints.Count - 1);
                break;
            case PatrolMode.Random:
                currentPatrolIndex = Random.Range(0, patrolPoints.Count);
                break;
        }
    }

    #endregion

#if UNITY_EDITOR
    private void OnDrawGizmosSelected()
    {
        Gizmos.color = new Color(1f, 1f, 0f, 0.2f);
        Gizmos.DrawWireSphere(transform.position, detectionRadius);

        Gizmos.color = new Color(1f, 0f, 0f, 0.3f);
        Gizmos.DrawWireSphere(transform.position, attackRange);

        Gizmos.color = Color.blue;
        for (int i = 0; i < patrolPoints.Count; i++)
        {
            if (patrolPoints[i] == null) continue;
            Gizmos.DrawWireSphere(patrolPoints[i].position, 0.3f);
            if (i < patrolPoints.Count - 1 && patrolPoints[i + 1] != null)
                Gizmos.DrawLine(patrolPoints[i].position, patrolPoints[i + 1].position);
        }
    }
#endif
}
