using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Object spawning system with interval, wave, burst, and manual modes.
/// Supports object pooling and multiple spawn points.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum SpawnMode
    {
        Interval,
        Wave,
        Burst,
        Manual
    }

    public enum SpawnPointMode
    {
        SpawnerPosition,
        Sequential,
        Random
    }

    [System.Serializable]
    public class WaveConfig
    {
        public int count = 5;
        public float delay;
        public float spawnInterval = 1f;
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string spawnerId = "{{SPAWNER_ID}}";

    [Header("Spawn Settings")]
    [SerializeField] private GameObject prefab;
    [SerializeField] private string prefabPath = "{{PREFAB_PATH}}";
    [SerializeField] private SpawnMode spawnMode = SpawnMode.{{SPAWN_MODE}};
    [SerializeField] private float spawnInterval = {{SPAWN_INTERVAL}};
    [SerializeField] private float initialDelay = {{INITIAL_DELAY}};
    [SerializeField] private bool autoStart = {{AUTO_START}};

    [Header("Limits")]
    [SerializeField] private int maxActive = {{MAX_ACTIVE}};
    [SerializeField] private int maxTotal = {{MAX_TOTAL}};

    [Header("Spawn Points")]
    [SerializeField] private SpawnPointMode spawnPointMode = SpawnPointMode.SpawnerPosition;
    [SerializeField] private List<Transform> spawnPoints = new List<Transform>();
    [SerializeField] private Vector3 positionRandomness = {{POSITION_RANDOMNESS}};

    [Header("Waves")]
    [SerializeField] private List<WaveConfig> waves = new List<WaveConfig>();
    [SerializeField] private bool loopWaves = {{LOOP_WAVES}};

    [Header("Pool")]
    [SerializeField] private bool usePool = {{USE_POOL}};
    [SerializeField] private int poolInitialSize = {{POOL_INITIAL_SIZE}};

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<GameObject> OnSpawned = new UnityEvent<GameObject>();
    public UnityEvent<GameObject> OnDespawned = new UnityEvent<GameObject>();
    public UnityEvent<int> OnWaveStarted = new UnityEvent<int>();
    public UnityEvent<int> OnWaveCompleted = new UnityEvent<int>();
    public UnityEvent OnAllWavesCompleted = new UnityEvent();
    public UnityEvent OnMaxActiveReached = new UnityEvent();

    #endregion

    #region State

    private readonly List<GameObject> activeInstances = new List<GameObject>();
    private readonly Queue<GameObject> pool = new Queue<GameObject>();
    private int totalSpawned;
    private int currentWaveIndex;
    private int currentSpawnPointIndex;
    private bool isSpawning;
    private Coroutine spawnCoroutine;

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var s) ? s : null;
    }

    #endregion

    #region Properties

    public string SpawnerId => spawnerId;
    public int ActiveCount => activeInstances.Count;
    public int TotalSpawned => totalSpawned;
    public bool IsSpawning => isSpawning;
    public int CurrentWave => currentWaveIndex;

    #endregion

    #region Lifecycle

    private void Awake()
    {
        if (usePool)
            InitializePool();
    }

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(spawnerId))
            _registry[spawnerId] = this;
        if (autoStart)
            StartSpawning();
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(spawnerId))
            _registry.Remove(spawnerId);
        StopSpawning();
    }

    #endregion

    #region Public API

    public void StartSpawning()
    {
        if (isSpawning) return;
        isSpawning = true;

        switch (spawnMode)
        {
            case SpawnMode.Interval:
                spawnCoroutine = StartCoroutine(IntervalSpawnRoutine());
                break;
            case SpawnMode.Wave:
                spawnCoroutine = StartCoroutine(WaveSpawnRoutine());
                break;
            case SpawnMode.Burst:
                SpawnBurst(maxActive);
                break;
        }
    }

    public void StopSpawning()
    {
        isSpawning = false;
        if (spawnCoroutine != null)
        {
            StopCoroutine(spawnCoroutine);
            spawnCoroutine = null;
        }
    }

    public void Reset()
    {
        StopSpawning();
        DespawnAll();
        totalSpawned = 0;
        currentWaveIndex = 0;
        currentSpawnPointIndex = 0;
    }

    public GameObject SpawnOne()
    {
        if (!CanSpawn()) return null;
        return SpawnInstance();
    }

    public List<GameObject> SpawnBurst(int count)
    {
        var spawned = new List<GameObject>();
        for (int i = 0; i < count; i++)
        {
            if (!CanSpawn()) break;
            var obj = SpawnInstance();
            if (obj != null) spawned.Add(obj);
        }
        return spawned;
    }

    public void Despawn(GameObject obj)
    {
        if (obj == null) return;
        activeInstances.Remove(obj);

        if (usePool)
        {
            obj.SetActive(false);
            pool.Enqueue(obj);
        }
        else
        {
            Destroy(obj);
        }

        OnDespawned?.Invoke(obj);
    }

    public void DespawnAll()
    {
        for (int i = activeInstances.Count - 1; i >= 0; i--)
            Despawn(activeInstances[i]);
    }

    public void AddSpawnPoint(Transform point)
    {
        if (point != null && !spawnPoints.Contains(point))
            spawnPoints.Add(point);
    }

    public void AddWave(int count, float delay, float interval)
    {
        waves.Add(new WaveConfig
        {
            count = count,
            delay = delay,
            spawnInterval = interval
        });
    }

    #endregion

    #region Internal

    private bool CanSpawn()
    {
        if (activeInstances.Count >= maxActive)
        {
            OnMaxActiveReached?.Invoke();
            return false;
        }
        if (maxTotal > 0 && totalSpawned >= maxTotal)
            return false;
        return true;
    }

    private GameObject SpawnInstance()
    {
        GameObject obj = null;

        if (usePool && pool.Count > 0)
        {
            obj = pool.Dequeue();
            obj.transform.position = GetSpawnPosition();
            obj.transform.rotation = transform.rotation;
            obj.SetActive(true);
        }
        else if (prefab != null)
        {
            obj = Instantiate(prefab, GetSpawnPosition(), transform.rotation);
        }

        if (obj != null)
        {
            activeInstances.Add(obj);
            totalSpawned++;
            OnSpawned?.Invoke(obj);
        }

        return obj;
    }

    private Vector3 GetSpawnPosition()
    {
        Vector3 basePos;

        switch (spawnPointMode)
        {
            case SpawnPointMode.Sequential:
                if (spawnPoints.Count > 0)
                {
                    basePos = spawnPoints[currentSpawnPointIndex % spawnPoints.Count].position;
                    currentSpawnPointIndex++;
                }
                else
                    basePos = transform.position;
                break;
            case SpawnPointMode.Random:
                if (spawnPoints.Count > 0)
                    basePos = spawnPoints[Random.Range(0, spawnPoints.Count)].position;
                else
                    basePos = transform.position;
                break;
            default:
                basePos = transform.position;
                break;
        }

        if (positionRandomness.sqrMagnitude > 0)
        {
            basePos += new Vector3(
                Random.Range(-positionRandomness.x, positionRandomness.x),
                Random.Range(-positionRandomness.y, positionRandomness.y),
                Random.Range(-positionRandomness.z, positionRandomness.z)
            );
        }

        return basePos;
    }

    private void InitializePool()
    {
        if (prefab == null) return;
        for (int i = 0; i < poolInitialSize; i++)
        {
            var obj = Instantiate(prefab, transform.position, Quaternion.identity);
            obj.SetActive(false);
            obj.transform.SetParent(transform);
            pool.Enqueue(obj);
        }
    }

    private IEnumerator IntervalSpawnRoutine()
    {
        if (initialDelay > 0)
            yield return new WaitForSeconds(initialDelay);

        while (isSpawning)
        {
            if (CanSpawn())
                SpawnInstance();
            yield return new WaitForSeconds(spawnInterval);
        }
    }

    private IEnumerator WaveSpawnRoutine()
    {
        if (initialDelay > 0)
            yield return new WaitForSeconds(initialDelay);

        while (isSpawning)
        {
            if (currentWaveIndex >= waves.Count)
            {
                if (loopWaves)
                    currentWaveIndex = 0;
                else
                {
                    OnAllWavesCompleted?.Invoke();
                    isSpawning = false;
                    yield break;
                }
            }

            var wave = waves[currentWaveIndex];
            OnWaveStarted?.Invoke(currentWaveIndex);

            if (wave.delay > 0)
                yield return new WaitForSeconds(wave.delay);

            for (int i = 0; i < wave.count; i++)
            {
                if (!isSpawning) yield break;
                if (CanSpawn())
                    SpawnInstance();
                if (wave.spawnInterval > 0 && i < wave.count - 1)
                    yield return new WaitForSeconds(wave.spawnInterval);
            }

            OnWaveCompleted?.Invoke(currentWaveIndex);
            currentWaveIndex++;
        }
    }

    private void CleanupDestroyedInstances()
    {
        activeInstances.RemoveAll(x => x == null);
    }

    #endregion

#if UNITY_EDITOR
    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.cyan;
        foreach (var sp in spawnPoints)
        {
            if (sp != null)
            {
                Gizmos.DrawWireSphere(sp.position, 0.3f);
                Gizmos.DrawLine(transform.position, sp.position);
            }
        }
    }
#endif
}
