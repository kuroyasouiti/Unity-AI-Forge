using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Composite effect definition supporting particle, sound, camera shake,
/// screen flash, and time scale effects.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum EffectType
    {
        Particle,
        Sound,
        CameraShake,
        ScreenFlash,
        TimeScale
    }

    [Serializable]
    public class EffectComponent
    {
        public EffectType type = EffectType.Particle;

        [Header("Particle")]
        public GameObject particlePrefab;
        public float particleDuration = 2f;
        public bool attachToTarget;
        public Vector3 positionOffset;
        public float particleScale = 1f;

        [Header("Sound")]
        public AudioClip audioClip;
        [Range(0f, 1f)] public float volume = 1f;
        [Range(0f, 0.5f)] public float pitchVariation;
        [Range(0f, 1f)] public float spatialBlend;

        [Header("Camera Shake")]
        public float shakeIntensity = 0.3f;
        public float shakeDuration = 0.2f;
        public float shakeFrequency = 25f;

        [Header("Screen Flash")]
        public Color flashColor = Color.white;
        public float flashDuration = 0.05f;
        public float flashFadeTime = 0.1f;

        [Header("Time Scale")]
        public float targetTimeScale = 0.1f;
        public float timeScaleDuration = 0.1f;
        public float timeScaleTransition = 0.05f;
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string effectId = "{{EFFECT_ID}}";

    [Header("Components")]
    [SerializeField] private List<EffectComponent> components = new List<EffectComponent>();

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent OnEffectStarted = new UnityEvent();
    public UnityEvent OnEffectCompleted = new UnityEvent();

    #endregion

    #region State

    private bool isPlaying;
    private readonly List<Coroutine> activeCoroutines = new List<Coroutine>();

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var e) ? e : null;
    }

    public static void Play(string id)
    {
        var effect = FindById(id);
        if (effect != null) effect.PlayEffect();
    }

    #endregion

    #region Properties

    public string EffectId => effectId;
    public bool IsPlaying => isPlaying;
    public int ComponentCount => components.Count;

    #endregion

    #region Lifecycle

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(effectId))
            _registry[effectId] = this;
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(effectId))
            _registry.Remove(effectId);
        StopEffect();
    }

    #endregion

    #region Public API

    public void PlayEffect()
    {
        PlayEffect(transform.position);
    }

    public void PlayEffect(Vector3 position)
    {
        StopEffect();
        isPlaying = true;
        OnEffectStarted?.Invoke();

        foreach (var comp in components)
            activeCoroutines.Add(StartCoroutine(PlayComponent(comp, position)));
    }

    public void StopEffect()
    {
        foreach (var co in activeCoroutines)
        {
            if (co != null) StopCoroutine(co);
        }
        activeCoroutines.Clear();
        isPlaying = false;
        Time.timeScale = 1f;
    }

    public void AddComponent(EffectComponent component)
    {
        if (component != null) components.Add(component);
    }

    public void RemoveComponentAt(int index)
    {
        if (index >= 0 && index < components.Count)
            components.RemoveAt(index);
    }

    public void ClearComponents()
    {
        components.Clear();
    }

    #endregion

    #region Internal

    private IEnumerator PlayComponent(EffectComponent comp, Vector3 position)
    {
        switch (comp.type)
        {
            case EffectType.Particle:
                yield return PlayParticle(comp, position);
                break;
            case EffectType.Sound:
                PlaySound(comp, position);
                break;
            case EffectType.CameraShake:
                yield return PlayCameraShake(comp);
                break;
            case EffectType.ScreenFlash:
                yield return PlayScreenFlash(comp);
                break;
            case EffectType.TimeScale:
                yield return PlayTimeScale(comp);
                break;
        }

        activeCoroutines.RemoveAll(c => c == null);
        if (activeCoroutines.Count <= 1)
        {
            isPlaying = false;
            OnEffectCompleted?.Invoke();
        }
    }

    private IEnumerator PlayParticle(EffectComponent comp, Vector3 position)
    {
        if (comp.particlePrefab == null) yield break;

        var spawnPos = position + comp.positionOffset;
        var instance = Instantiate(comp.particlePrefab, spawnPos, Quaternion.identity);

        if (comp.particleScale != 1f)
            instance.transform.localScale *= comp.particleScale;

        if (comp.attachToTarget)
            instance.transform.SetParent(transform);

        var ps = instance.GetComponent<ParticleSystem>();
        float lifetime = comp.particleDuration;
        if (ps != null)
        {
            var main = ps.main;
            lifetime = Mathf.Max(lifetime, main.duration + main.startLifetime.constantMax);
        }

        Destroy(instance, lifetime);
        yield return new WaitForSeconds(lifetime);
    }

    private void PlaySound(EffectComponent comp, Vector3 position)
    {
        if (comp.audioClip == null) return;

        var source = GetComponent<AudioSource>();
        if (source == null) source = gameObject.AddComponent<AudioSource>();

        source.spatialBlend = comp.spatialBlend;
        if (comp.pitchVariation > 0)
            source.pitch = 1f + UnityEngine.Random.Range(-comp.pitchVariation, comp.pitchVariation);
        else
            source.pitch = 1f;

        source.PlayOneShot(comp.audioClip, comp.volume);
    }

    private IEnumerator PlayCameraShake(EffectComponent comp)
    {
        var cam = Camera.main;
        if (cam == null) yield break;

        var camTransform = cam.transform;
        var origPos = camTransform.localPosition;
        float elapsed = 0;

        while (elapsed < comp.shakeDuration)
        {
            float t = elapsed / comp.shakeDuration;
            float dampedIntensity = comp.shakeIntensity * (1f - t);
            float x = (Mathf.PerlinNoise(Time.time * comp.shakeFrequency, 0) * 2f - 1f) * dampedIntensity;
            float y = (Mathf.PerlinNoise(0, Time.time * comp.shakeFrequency) * 2f - 1f) * dampedIntensity;
            camTransform.localPosition = origPos + new Vector3(x, y, 0);
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }

        camTransform.localPosition = origPos;
    }

    private IEnumerator PlayScreenFlash(EffectComponent comp)
    {
        var renderer = GetComponent<SpriteRenderer>();
        if (renderer == null) renderer = GetComponentInChildren<SpriteRenderer>();
        if (renderer == null) yield break;

        var origColor = renderer.color;
        renderer.color = comp.flashColor;

        yield return new WaitForSecondsRealtime(comp.flashDuration);

        float elapsed = 0;
        while (elapsed < comp.flashFadeTime)
        {
            float t = elapsed / comp.flashFadeTime;
            renderer.color = Color.Lerp(comp.flashColor, origColor, t);
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
        renderer.color = origColor;
    }

    private IEnumerator PlayTimeScale(EffectComponent comp)
    {
        float originalScale = Time.timeScale;

        float elapsed = 0;
        while (elapsed < comp.timeScaleTransition)
        {
            Time.timeScale = Mathf.Lerp(originalScale, comp.targetTimeScale, elapsed / comp.timeScaleTransition);
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
        Time.timeScale = comp.targetTimeScale;

        yield return new WaitForSecondsRealtime(comp.timeScaleDuration);

        elapsed = 0;
        while (elapsed < comp.timeScaleTransition)
        {
            Time.timeScale = Mathf.Lerp(comp.targetTimeScale, 1f, elapsed / comp.timeScaleTransition);
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
        Time.timeScale = 1f;
    }

    #endregion
}
