using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Unified combat system with melee, ranged, AoE, and projectile attacks.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum AttackType
    {
        Melee,
        Ranged,
        AoE,
        Projectile
    }

    public enum HitboxShape
    {
        Sphere,
        Box,
        Capsule,
        Cone,
        Circle
    }

    [System.Serializable]
    public class AttackResult
    {
        public bool didHit;
        public float damageDealt;
        public bool wasCritical;
        public List<HitResult> hits = new List<HitResult>();
    }

    [System.Serializable]
    public class HitResult
    {
        public GameObject target;
        public float damage;
        public bool critical;
        public Vector3 hitPoint;
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string combatId = "{{COMBAT_ID}}";

    [Header("Attack Settings")]
    [SerializeField] private AttackType attackType = AttackType.{{ATTACK_TYPE}};
    [SerializeField] private float baseDamage = {{BASE_DAMAGE}};
    [SerializeField] private float damageVariance = {{DAMAGE_VARIANCE}};
    [SerializeField] private float critChance = {{CRIT_CHANCE}};
    [SerializeField] private float critMultiplier = {{CRIT_MULTIPLIER}};
    [SerializeField] private float attackCooldown = {{ATTACK_COOLDOWN}};

    [Header("Targeting")]
    [SerializeField] private string[] targetTags = new string[] { {{TARGET_TAGS}} };
    [SerializeField] private bool hitMultipleTargets = {{HIT_MULTIPLE}};
    [SerializeField] private int maxTargets = {{MAX_TARGETS}};

    [Header("Hitbox")]
    [SerializeField] private HitboxShape hitboxShape = HitboxShape.{{HITBOX_SHAPE}};
    [SerializeField] private float hitboxRadius = {{HITBOX_RADIUS}};
    [SerializeField] private Vector3 hitboxSize = {{HITBOX_SIZE}};
    [SerializeField] private Vector3 hitboxOffset = {{HITBOX_OFFSET}};

    [Header("Ranged")]
    [SerializeField] private float castDistance = {{CAST_DISTANCE}};
    [SerializeField] private LayerMask raycastLayerMask = ~0;

    [Header("AoE")]
    [SerializeField] private float areaRadius = {{AREA_RADIUS}};

    [Header("Projectile")]
    [SerializeField] private GameObject projectilePrefab;
    [SerializeField] private float projectileSpeed = {{PROJECTILE_SPEED}};
    [SerializeField] private string projectilePrefabPath = "{{PROJECTILE_PREFAB_PATH}}";

    [Header("Effects")]
    [SerializeField] private string onHitEffectId = "{{ON_HIT_EFFECT_ID}}";
    [SerializeField] private string onCritEffectId = "{{ON_CRIT_EFFECT_ID}}";

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<AttackResult> OnAttack = new UnityEvent<AttackResult>();
    public UnityEvent<HitResult> OnHit = new UnityEvent<HitResult>();
    public UnityEvent<HitResult> OnCrit = new UnityEvent<HitResult>();
    public UnityEvent OnMiss = new UnityEvent();
    public UnityEvent<GameObject> OnKill = new UnityEvent<GameObject>();
    public UnityEvent OnCooldownReady = new UnityEvent();

    #endregion

    #region State

    private float cooldownTimer;
    private bool isOnCooldown;

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var c) ? c : null;
    }

    #endregion

    #region Properties

    public string CombatId => combatId;
    public AttackType Type => attackType;
    public float BaseDamage => baseDamage;
    public float CritChance => critChance;
    public bool IsOnCooldown => isOnCooldown;
    public float CooldownRemaining => isOnCooldown ? cooldownTimer : 0f;
    public bool CanAttack => !isOnCooldown;

    #endregion

    #region Lifecycle

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(combatId))
            _registry[combatId] = this;
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(combatId))
            _registry.Remove(combatId);
    }

    private void Update()
    {
        if (isOnCooldown)
        {
            cooldownTimer -= Time.deltaTime;
            if (cooldownTimer <= 0)
            {
                isOnCooldown = false;
                OnCooldownReady?.Invoke();
            }
        }
    }

    #endregion

    #region Public API

    public AttackResult Attack()
    {
        if (isOnCooldown)
            return new AttackResult { didHit = false };

        AttackResult result;
        switch (attackType)
        {
            case AttackType.Melee:
                result = PerformMeleeAttack();
                break;
            case AttackType.Ranged:
                result = PerformRangedAttack();
                break;
            case AttackType.AoE:
                result = PerformAoEAttack();
                break;
            case AttackType.Projectile:
                result = PerformProjectileAttack();
                break;
            default:
                result = new AttackResult { didHit = false };
                break;
        }

        StartCooldown();
        OnAttack?.Invoke(result);

        if (!result.didHit)
            OnMiss?.Invoke();

        return result;
    }

    public AttackResult AttackTarget(GameObject target)
    {
        if (isOnCooldown || target == null)
            return new AttackResult { didHit = false };

        float damage = CalculateDamage(out bool isCrit);
        var hitResult = ApplyDamage(target, damage, isCrit, target.transform.position);

        var result = new AttackResult
        {
            didHit = hitResult != null,
            damageDealt = hitResult?.damage ?? 0f,
            wasCritical = isCrit
        };
        if (hitResult != null) result.hits.Add(hitResult);

        StartCooldown();
        OnAttack?.Invoke(result);
        return result;
    }

    public void ResetCooldown()
    {
        isOnCooldown = false;
        cooldownTimer = 0;
    }

    public void SetBaseDamage(float damage)
    {
        baseDamage = Mathf.Max(0, damage);
    }

    public void AddTargetTag(string tag)
    {
        var list = new List<string>(targetTags);
        if (!list.Contains(tag)) list.Add(tag);
        targetTags = list.ToArray();
    }

    public void RemoveTargetTag(string tag)
    {
        var list = new List<string>(targetTags);
        list.Remove(tag);
        targetTags = list.ToArray();
    }

    #endregion

    #region Internal

    private float CalculateDamage(out bool isCrit)
    {
        float damage = baseDamage + Random.Range(-damageVariance, damageVariance);
        isCrit = Random.value < critChance;
        if (isCrit)
            damage *= critMultiplier;
        return Mathf.Max(0, damage);
    }

    private void StartCooldown()
    {
        if (attackCooldown > 0)
        {
            isOnCooldown = true;
            cooldownTimer = attackCooldown;
        }
    }

    private bool IsValidTarget(GameObject target)
    {
        if (target == null || target == gameObject) return false;
        if (targetTags == null || targetTags.Length == 0) return true;
        foreach (var tag in targetTags)
        {
            if (target.CompareTag(tag)) return true;
        }
        return false;
    }

    private AttackResult PerformMeleeAttack()
    {
        var result = new AttackResult();
        Vector3 origin = transform.position + transform.TransformDirection(hitboxOffset);
        Collider[] hits = Physics.OverlapSphere(origin, hitboxRadius);

        int hitCount = 0;
        foreach (var hit in hits)
        {
            if (!IsValidTarget(hit.gameObject)) continue;
            if (!hitMultipleTargets && hitCount >= 1) break;
            if (hitCount >= maxTargets) break;

            float damage = CalculateDamage(out bool isCrit);
            var hitResult = ApplyDamage(hit.gameObject, damage, isCrit, hit.ClosestPoint(origin));
            if (hitResult != null)
            {
                result.hits.Add(hitResult);
                result.didHit = true;
                hitCount++;
            }
        }

        if (result.hits.Count > 0)
            result.damageDealt = result.hits[0].damage;

        return result;
    }

    private AttackResult PerformRangedAttack()
    {
        var result = new AttackResult();
        Vector3 origin = transform.position + transform.TransformDirection(hitboxOffset);
        Vector3 direction = transform.forward;

        if (Physics.Raycast(origin, direction, out RaycastHit hit, castDistance, raycastLayerMask))
        {
            if (IsValidTarget(hit.collider.gameObject))
            {
                float damage = CalculateDamage(out bool isCrit);
                var hitResult = ApplyDamage(hit.collider.gameObject, damage, isCrit, hit.point);
                if (hitResult != null)
                {
                    result.hits.Add(hitResult);
                    result.didHit = true;
                    result.damageDealt = hitResult.damage;
                }
            }
        }

        return result;
    }

    private AttackResult PerformAoEAttack()
    {
        var result = new AttackResult();
        Vector3 origin = transform.position + transform.TransformDirection(hitboxOffset);
        Collider[] hits = Physics.OverlapSphere(origin, areaRadius);

        foreach (var hit in hits)
        {
            if (!IsValidTarget(hit.gameObject)) continue;

            float damage = CalculateDamage(out bool isCrit);
            float dist = Vector3.Distance(origin, hit.transform.position);
            float falloff = 1f - Mathf.Clamp01(dist / areaRadius);
            damage *= falloff;

            var hitResult = ApplyDamage(hit.gameObject, damage, isCrit, hit.ClosestPoint(origin));
            if (hitResult != null)
            {
                result.hits.Add(hitResult);
                result.didHit = true;
            }
        }

        if (result.hits.Count > 0)
            result.damageDealt = result.hits[0].damage;

        return result;
    }

    private AttackResult PerformProjectileAttack()
    {
        var result = new AttackResult { didHit = true };

        if (projectilePrefab != null)
        {
            Vector3 spawnPos = transform.position + transform.TransformDirection(hitboxOffset);
            var proj = Instantiate(projectilePrefab, spawnPos, transform.rotation);
            var rb = proj.GetComponent<Rigidbody>();
            if (rb != null)
                rb.linearVelocity = transform.forward * projectileSpeed;
            var rb2d = proj.GetComponent<Rigidbody2D>();
            if (rb2d != null)
                rb2d.linearVelocity = transform.right * projectileSpeed;
        }

        return result;
    }

    private HitResult ApplyDamage(GameObject target, float damage, bool isCrit, Vector3 hitPoint)
    {
        var hitResult = new HitResult
        {
            target = target,
            damage = damage,
            critical = isCrit,
            hitPoint = hitPoint
        };

        target.SendMessage("TakeDamage", damage, SendMessageOptions.DontRequireReceiver);

        if (isCrit)
            OnCrit?.Invoke(hitResult);
        else
            OnHit?.Invoke(hitResult);

        return hitResult;
    }

    #endregion

#if UNITY_EDITOR
    private void OnDrawGizmosSelected()
    {
        Gizmos.color = new Color(1f, 0.3f, 0.3f, 0.3f);
        Vector3 origin = transform.position + transform.TransformDirection(hitboxOffset);

        switch (attackType)
        {
            case AttackType.Melee:
                Gizmos.DrawWireSphere(origin, hitboxRadius);
                break;
            case AttackType.Ranged:
                Gizmos.DrawRay(origin, transform.forward * castDistance);
                break;
            case AttackType.AoE:
                Gizmos.DrawWireSphere(origin, areaRadius);
                break;
        }
    }
#endif
}
