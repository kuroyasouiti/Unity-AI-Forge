using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

/// <summary>
/// UI command panel that binds buttons to game actions via UnityEvents.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum CommandType
    {
        Move,
        Jump,
        Action,
        Look,
        Custom
    }

    [Serializable]
    public class UICommandBinding
    {
        public string commandName;
        public CommandType commandType = CommandType.Action;
        public Button button;
        public Vector3 moveDirection = Vector3.zero;
        public Vector2 lookDirection = Vector2.zero;
        public string commandParameter;
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string panelId = "{{PANEL_ID}}";

    [Header("Commands")]
    [SerializeField] private List<UICommandBinding> commandBindings = new List<UICommandBinding>();
    [SerializeField] private bool logCommands = false;

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<string> OnCommandExecuted = new UnityEvent<string>();
    public UnityEvent<Vector3> OnMoveCommand = new UnityEvent<Vector3>();
    public UnityEvent OnJumpCommand = new UnityEvent();
    public UnityEvent<string> OnActionCommand = new UnityEvent<string>();
    public UnityEvent<Vector2> OnLookCommand = new UnityEvent<Vector2>();

    #endregion

    #region State

    private readonly Dictionary<string, UICommandBinding> bindingLookup =
        new Dictionary<string, UICommandBinding>();

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var c) ? c : null;
    }

    #endregion

    #region Properties

    public string PanelId => panelId;

    #endregion

    #region Lifecycle

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(panelId))
            _registry[panelId] = this;
        RebuildLookup();
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(panelId))
            _registry.Remove(panelId);
    }

    #endregion

    #region Public API

    public void RegisterButton(string commandName, Button button, CommandType commandType = CommandType.Action, string commandParam = null)
    {
        if (button == null || string.IsNullOrEmpty(commandName)) return;

        var binding = new UICommandBinding
        {
            commandName = commandName,
            commandType = commandType,
            button = button,
            commandParameter = commandParam
        };

        commandBindings.Add(binding);
        bindingLookup[commandName] = binding;

        button.onClick.AddListener(() => ExecuteCommand(commandName));
    }

    public void RegisterDirectionalButton(string commandName, Button button, Vector3 direction)
    {
        if (button == null || string.IsNullOrEmpty(commandName)) return;

        var binding = new UICommandBinding
        {
            commandName = commandName,
            commandType = CommandType.Move,
            button = button,
            moveDirection = direction
        };

        commandBindings.Add(binding);
        bindingLookup[commandName] = binding;

        button.onClick.AddListener(() => ExecuteMoveCommand(direction));
    }

    public void ExecuteCommand(string commandName)
    {
        if (!bindingLookup.TryGetValue(commandName, out var binding)) return;

        if (logCommands) Debug.Log($"[{panelId}] Command: {commandName} ({binding.commandType})");

        switch (binding.commandType)
        {
            case CommandType.Move:
                ExecuteMoveCommand(binding.moveDirection);
                break;
            case CommandType.Jump:
                ExecuteJumpCommand();
                break;
            case CommandType.Action:
                ExecuteActionCommand(binding.commandParameter ?? commandName);
                break;
            case CommandType.Look:
                ExecuteLookCommand(binding.lookDirection);
                break;
            case CommandType.Custom:
                OnCommandExecuted?.Invoke(commandName);
                break;
        }
    }

    public void ExecuteMoveCommand(Vector3 direction)
    {
        OnMoveCommand?.Invoke(direction);
        OnCommandExecuted?.Invoke("move");
    }

    public void ExecuteJumpCommand()
    {
        OnJumpCommand?.Invoke();
        OnCommandExecuted?.Invoke("jump");
    }

    public void ExecuteActionCommand(string actionName)
    {
        OnActionCommand?.Invoke(actionName);
        OnCommandExecuted?.Invoke(actionName);
    }

    public void ExecuteLookCommand(Vector2 direction)
    {
        OnLookCommand?.Invoke(direction);
        OnCommandExecuted?.Invoke("look");
    }

    public void ClearBindings()
    {
        foreach (var binding in commandBindings)
        {
            if (binding.button != null)
                binding.button.onClick.RemoveAllListeners();
        }
        commandBindings.Clear();
        bindingLookup.Clear();
    }

    public List<string> GetCommandNames()
    {
        return new List<string>(bindingLookup.Keys);
    }

    public bool HasCommand(string commandName)
    {
        return bindingLookup.ContainsKey(commandName);
    }

    #endregion

    #region Internal

    private void RebuildLookup()
    {
        bindingLookup.Clear();
        foreach (var binding in commandBindings)
        {
            if (!string.IsNullOrEmpty(binding.commandName))
            {
                bindingLookup[binding.commandName] = binding;
                if (binding.button != null)
                {
                    var name = binding.commandName;
                    binding.button.onClick.RemoveAllListeners();
                    binding.button.onClick.AddListener(() => ExecuteCommand(name));
                }
            }
        }
    }

    #endregion
}
