using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Inventory system with item stacking, equipment slots, and save/load support.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    [System.Serializable]
    public class InventorySlot
    {
        public string itemId;
        public string displayName;
        public string category;
        public int quantity;
        public bool stackable;
        public int maxStack;
        public string customData;

        public bool IsEmpty => string.IsNullOrEmpty(itemId);
    }

    [System.Serializable]
    public class EquippedItem
    {
        public string equipSlot;
        public string itemId;
        public string displayName;
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string inventoryId = "{{INVENTORY_ID}}";

    [Header("Capacity")]
    [SerializeField] private int maxSlots = {{MAX_SLOTS}};
    [SerializeField] private int defaultMaxStack = {{DEFAULT_MAX_STACK}};

    [Header("Filtering")]
    [SerializeField] private List<string> allowedCategories = new List<string>();
    [SerializeField] private List<string> stackableCategories = new List<string>();

    #endregion

    #region State

    [Header("Contents")]
    [SerializeField] private List<InventorySlot> slots = new List<InventorySlot>();
    [SerializeField] private List<EquippedItem> equippedItems = new List<EquippedItem>();

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<string, int> OnItemAdded = new UnityEvent<string, int>();
    public UnityEvent<string, int> OnItemRemoved = new UnityEvent<string, int>();
    public UnityEvent<string> OnItemUsed = new UnityEvent<string>();
    public UnityEvent<string, string> OnItemEquipped = new UnityEvent<string, string>();
    public UnityEvent<string, string> OnItemUnequipped = new UnityEvent<string, string>();
    public UnityEvent OnInventoryChanged = new UnityEvent();
    public UnityEvent OnInventoryFull = new UnityEvent();

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var inv) ? inv : null;
    }

    #endregion

    #region Properties

    public string InventoryId => inventoryId;
    public int MaxSlots => maxSlots;
    public int UsedSlots => slots.Count(s => !s.IsEmpty);
    public int FreeSlots => maxSlots - UsedSlots;
    public bool IsFull => FreeSlots <= 0;
    public IReadOnlyList<InventorySlot> Slots => slots;
    public IReadOnlyList<EquippedItem> Equipped => equippedItems;

    #endregion

    #region Lifecycle

    private void Awake()
    {
        while (slots.Count < maxSlots)
            slots.Add(new InventorySlot());
    }

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(inventoryId))
            _registry[inventoryId] = this;
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(inventoryId))
            _registry.Remove(inventoryId);
    }

    #endregion

    #region Public API

    public bool AddItem(string itemId, string displayName, string category, int quantity = 1,
        bool stackable = true, int maxStack = -1, string customData = null)
    {
        if (string.IsNullOrEmpty(itemId) || quantity <= 0) return false;
        if (allowedCategories.Count > 0 && !allowedCategories.Contains(category)) return false;

        int ms = maxStack > 0 ? maxStack : defaultMaxStack;
        bool isStackable = stackable && (stackableCategories.Count == 0 || stackableCategories.Contains(category));

        int remaining = quantity;

        if (isStackable)
        {
            foreach (var slot in slots)
            {
                if (slot.itemId == itemId && slot.quantity < ms)
                {
                    int canAdd = Mathf.Min(remaining, ms - slot.quantity);
                    slot.quantity += canAdd;
                    remaining -= canAdd;
                    if (remaining <= 0) break;
                }
            }
        }

        while (remaining > 0)
        {
            var emptySlot = slots.FirstOrDefault(s => s.IsEmpty);
            if (emptySlot == null)
            {
                OnInventoryFull?.Invoke();
                if (remaining < quantity)
                {
                    OnItemAdded?.Invoke(itemId, quantity - remaining);
                    OnInventoryChanged?.Invoke();
                }
                return false;
            }

            int toAdd = isStackable ? Mathf.Min(remaining, ms) : 1;
            emptySlot.itemId = itemId;
            emptySlot.displayName = displayName;
            emptySlot.category = category;
            emptySlot.quantity = toAdd;
            emptySlot.stackable = stackable;
            emptySlot.maxStack = ms;
            emptySlot.customData = customData;
            remaining -= toAdd;
        }

        OnItemAdded?.Invoke(itemId, quantity);
        OnInventoryChanged?.Invoke();
        return true;
    }

    public bool RemoveItem(string itemId, int quantity = 1)
    {
        if (string.IsNullOrEmpty(itemId) || quantity <= 0) return false;
        if (GetItemCount(itemId) < quantity) return false;

        int remaining = quantity;
        for (int i = slots.Count - 1; i >= 0 && remaining > 0; i--)
        {
            if (slots[i].itemId != itemId) continue;
            int toRemove = Mathf.Min(remaining, slots[i].quantity);
            slots[i].quantity -= toRemove;
            remaining -= toRemove;

            if (slots[i].quantity <= 0)
                ClearSlot(slots[i]);
        }

        OnItemRemoved?.Invoke(itemId, quantity);
        OnInventoryChanged?.Invoke();
        return true;
    }

    public bool RemoveItemFromSlot(int slotIndex, int quantity = 1)
    {
        if (slotIndex < 0 || slotIndex >= slots.Count) return false;
        var slot = slots[slotIndex];
        if (slot.IsEmpty) return false;

        string id = slot.itemId;
        int toRemove = Mathf.Min(quantity, slot.quantity);
        slot.quantity -= toRemove;

        if (slot.quantity <= 0)
            ClearSlot(slot);

        OnItemRemoved?.Invoke(id, toRemove);
        OnInventoryChanged?.Invoke();
        return true;
    }

    public void UseItem(int slotIndex)
    {
        if (slotIndex < 0 || slotIndex >= slots.Count) return;
        var slot = slots[slotIndex];
        if (slot.IsEmpty) return;

        OnItemUsed?.Invoke(slot.itemId);
    }

    public bool Equip(int slotIndex, string equipSlot)
    {
        if (slotIndex < 0 || slotIndex >= slots.Count) return false;
        var slot = slots[slotIndex];
        if (slot.IsEmpty) return false;

        Unequip(equipSlot);

        equippedItems.Add(new EquippedItem
        {
            equipSlot = equipSlot,
            itemId = slot.itemId,
            displayName = slot.displayName
        });

        OnItemEquipped?.Invoke(slot.itemId, equipSlot);
        OnInventoryChanged?.Invoke();
        return true;
    }

    public bool Unequip(string equipSlot)
    {
        var equipped = equippedItems.Find(e => e.equipSlot == equipSlot);
        if (equipped == null) return false;

        equippedItems.Remove(equipped);
        OnItemUnequipped?.Invoke(equipped.itemId, equipSlot);
        OnInventoryChanged?.Invoke();
        return true;
    }

    public bool HasItem(string itemId, int minQuantity = 1)
    {
        return GetItemCount(itemId) >= minQuantity;
    }

    public int GetItemCount(string itemId)
    {
        int count = 0;
        foreach (var slot in slots)
        {
            if (slot.itemId == itemId)
                count += slot.quantity;
        }
        return count;
    }

    public InventorySlot GetSlot(int index)
    {
        if (index < 0 || index >= slots.Count) return null;
        return slots[index];
    }

    public void Clear()
    {
        foreach (var slot in slots)
            ClearSlot(slot);
        equippedItems.Clear();
        OnInventoryChanged?.Invoke();
    }

    public void Sort()
    {
        var items = slots.Where(s => !s.IsEmpty).OrderBy(s => s.category).ThenBy(s => s.itemId).ToList();
        var empty = slots.Where(s => s.IsEmpty).ToList();
        slots.Clear();
        slots.AddRange(items);
        slots.AddRange(empty);
        while (slots.Count < maxSlots)
            slots.Add(new InventorySlot());
        OnInventoryChanged?.Invoke();
    }

    #endregion

    #region Save/Load

    [System.Serializable]
    public class InventorySaveData
    {
        public List<SlotSaveData> slots = new List<SlotSaveData>();
        public List<EquippedItem> equipped = new List<EquippedItem>();
    }

    [System.Serializable]
    public class SlotSaveData
    {
        public string itemId;
        public string displayName;
        public string category;
        public int quantity;
        public bool stackable;
        public int maxStack;
    }

    public string GetSaveData()
    {
        var data = new InventorySaveData();
        foreach (var slot in slots)
        {
            if (slot.IsEmpty) continue;
            data.slots.Add(new SlotSaveData
            {
                itemId = slot.itemId,
                displayName = slot.displayName,
                category = slot.category,
                quantity = slot.quantity,
                stackable = slot.stackable,
                maxStack = slot.maxStack
            });
        }
        data.equipped.AddRange(equippedItems);
        return JsonUtility.ToJson(data);
    }

    public void LoadSaveData(string json)
    {
        if (string.IsNullOrEmpty(json)) return;
        var data = JsonUtility.FromJson<InventorySaveData>(json);
        Clear();
        foreach (var slotData in data.slots)
        {
            AddItem(slotData.itemId, slotData.displayName, slotData.category,
                slotData.quantity, slotData.stackable, slotData.maxStack);
        }
        equippedItems.Clear();
        equippedItems.AddRange(data.equipped);
        OnInventoryChanged?.Invoke();
    }

    #endregion

    #region Internal

    private void ClearSlot(InventorySlot slot)
    {
        slot.itemId = null;
        slot.displayName = null;
        slot.category = null;
        slot.quantity = 0;
        slot.stackable = false;
        slot.maxStack = 0;
        slot.customData = null;
    }

    #endregion
}
