using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Configurable timer with loop, pause, and unscaled time support.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Settings

    [Header("Identity")]
    [SerializeField] private string timerId = "{{TIMER_ID}}";

    [Header("Timer Settings")]
    [SerializeField] private float duration = {{DURATION}};
    [SerializeField] private bool loop = {{LOOP}};
    [SerializeField] private bool autoStart = {{AUTO_START}};
    [SerializeField] private bool unscaledTime = {{UNSCALED_TIME}};

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent OnTimerStarted = new UnityEvent();
    public UnityEvent OnTimerCompleted = new UnityEvent();
    public UnityEvent OnTimerPaused = new UnityEvent();
    public UnityEvent OnTimerResumed = new UnityEvent();
    public UnityEvent OnTimerStopped = new UnityEvent();
    public UnityEvent<float> OnTimerTick = new UnityEvent<float>();

    #endregion

    #region State

    private float elapsed;
    private bool isRunning;
    private bool isPaused;
    private int completionCount;

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var t) ? t : null;
    }

    #endregion

    #region Properties

    public string TimerId => timerId;
    public float Duration => duration;
    public float Elapsed => elapsed;
    public float Remaining => Mathf.Max(0, duration - elapsed);
    public float Progress => duration > 0 ? Mathf.Clamp01(elapsed / duration) : 0f;
    public bool IsRunning => isRunning && !isPaused;
    public bool IsPaused => isPaused;
    public int CompletionCount => completionCount;

    #endregion

    #region Lifecycle

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(timerId))
            _registry[timerId] = this;
        if (autoStart)
            StartTimer();
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(timerId))
            _registry.Remove(timerId);
    }

    private void Update()
    {
        if (!isRunning || isPaused) return;

        float dt = unscaledTime ? Time.unscaledDeltaTime : Time.deltaTime;
        elapsed += dt;
        OnTimerTick?.Invoke(elapsed);

        if (elapsed >= duration)
        {
            completionCount++;
            OnTimerCompleted?.Invoke();

            if (loop)
            {
                elapsed -= duration;
            }
            else
            {
                isRunning = false;
            }
        }
    }

    #endregion

    #region Public API

    public void StartTimer()
    {
        elapsed = 0;
        isRunning = true;
        isPaused = false;
        OnTimerStarted?.Invoke();
    }

    public void StartTimer(float newDuration)
    {
        duration = newDuration;
        StartTimer();
    }

    public void PauseTimer()
    {
        if (!isRunning || isPaused) return;
        isPaused = true;
        OnTimerPaused?.Invoke();
    }

    public void ResumeTimer()
    {
        if (!isRunning || !isPaused) return;
        isPaused = false;
        OnTimerResumed?.Invoke();
    }

    public void StopTimer()
    {
        isRunning = false;
        isPaused = false;
        OnTimerStopped?.Invoke();
    }

    public void ResetTimer()
    {
        elapsed = 0;
        completionCount = 0;
    }

    public void SetDuration(float newDuration)
    {
        duration = Mathf.Max(0, newDuration);
    }

    #endregion
}
