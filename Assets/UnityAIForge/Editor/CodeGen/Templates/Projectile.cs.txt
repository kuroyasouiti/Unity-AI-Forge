using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Projectile system with transform/physics movement, homing, bounce, and pierce support.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum MovementType
    {
        Transform,
        Rigidbody,
        Rigidbody2D
    }

    public enum DestroyBehavior
    {
        OnHit,
        OnLifetimeEnd,
        OnBounceLimit,
        Manual
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string projectileId = "{{PROJECTILE_ID}}";

    [Header("Movement")]
    [SerializeField] private MovementType movementType = MovementType.{{MOVEMENT_TYPE}};
    [SerializeField] private float speed = {{SPEED}};
    [SerializeField] private float lifetime = {{LIFETIME}};
    [SerializeField] private bool useGravity = {{USE_GRAVITY}};
    [SerializeField] private float gravityScale = {{GRAVITY_SCALE}};

    [Header("Damage")]
    [SerializeField] private float damage = {{DAMAGE}};
    [SerializeField] private bool damageOnHit = {{DAMAGE_ON_HIT}};
    [SerializeField] private string targetTag = "{{TARGET_TAG}}";
    [SerializeField] private LayerMask targetLayers = -1;

    [Header("Bounce")]
    [SerializeField] private bool canBounce = {{CAN_BOUNCE}};
    [SerializeField] private int maxBounces = {{MAX_BOUNCES}};
    [SerializeField] private float bounciness = {{BOUNCINESS}};

    [Header("Homing")]
    [SerializeField] private bool isHoming = {{IS_HOMING}};
    [SerializeField] private Transform homingTarget;
    [SerializeField] private float homingStrength = {{HOMING_STRENGTH}};
    [SerializeField] private float maxHomingAngle = {{MAX_HOMING_ANGLE}};

    [Header("Pierce")]
    [SerializeField] private bool canPierce = {{CAN_PIERCE}};
    [SerializeField] private int maxPierceCount = {{MAX_PIERCE_COUNT}};
    [SerializeField] private float pierceDamageReduction = {{PIERCE_DAMAGE_REDUCTION}};

    [Header("Effects")]
    [SerializeField] private GameObject hitEffect;
    [SerializeField] private GameObject trailEffect;
    [SerializeField] private AudioClip hitSound;
    [SerializeField] private AudioClip launchSound;
    [SerializeField] private float effectDuration = {{EFFECT_DURATION}};

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<GameObject> OnHit = new UnityEvent<GameObject>();
    public UnityEvent OnDestroyed = new UnityEvent();
    public UnityEvent<Vector3> OnBounce = new UnityEvent<Vector3>();

    #endregion

    #region State

    private Vector3 direction;
    private GameObject owner;
    private Rigidbody rb;
    private Rigidbody2D rb2d;
    private float lifetimeTimer;
    private int bounceCount;
    private int pierceCount;
    private float currentDamage;
    private bool isLaunched;

    #endregion

    #region Properties

    public string ProjectileId => projectileId;
    public float Damage => currentDamage;
    public bool IsLaunched => isLaunched;
    public GameObject Owner => owner;

    #endregion

    #region Public API

    public static {{CLASS_NAME}} Spawn(GameObject prefab, Vector3 position, Vector3 dir, GameObject projectileOwner = null)
    {
        if (prefab == null) return null;
        var instance = Instantiate(prefab, position, Quaternion.LookRotation(dir != Vector3.zero ? dir : Vector3.forward));
        var proj = instance.GetComponent<{{CLASS_NAME}}>();
        if (proj != null) proj.Launch(dir, projectileOwner);
        return proj;
    }

    public void Launch(Vector3 dir, GameObject projectileOwner = null)
    {
        direction = dir.normalized;
        owner = projectileOwner;
        currentDamage = damage;
        lifetimeTimer = lifetime;
        bounceCount = 0;
        pierceCount = 0;
        isLaunched = true;

        transform.rotation = Quaternion.LookRotation(direction != Vector3.zero ? direction : Vector3.forward);

        rb = GetComponent<Rigidbody>();
        rb2d = GetComponent<Rigidbody2D>();

        if (movementType == MovementType.Rigidbody && rb != null)
            rb.linearVelocity = direction * speed;
        else if (movementType == MovementType.Rigidbody2D && rb2d != null)
            rb2d.linearVelocity = (Vector2)(direction * speed);

        if (launchSound != null)
            AudioSource.PlayClipAtPoint(launchSound, transform.position);
    }

    public void LaunchAt(Vector3 targetPosition, GameObject projectileOwner = null)
    {
        Launch((targetPosition - transform.position).normalized, projectileOwner);
    }

    public void LaunchAt(Transform target, GameObject projectileOwner = null)
    {
        if (target == null) return;
        homingTarget = target;
        Launch((target.position - transform.position).normalized, projectileOwner);
    }

    public void SetHomingTarget(Transform target) => homingTarget = target;

    public void DestroyProjectile()
    {
        isLaunched = false;
        OnDestroyed?.Invoke();
        Destroy(gameObject);
    }

    #endregion

    #region Lifecycle

    private void Update()
    {
        if (!isLaunched) return;

        lifetimeTimer -= Time.deltaTime;
        if (lifetimeTimer <= 0)
        {
            DestroyProjectile();
            return;
        }

        if (isHoming && homingTarget != null)
            ApplyHoming();

        if (movementType == MovementType.Transform)
            transform.position += direction * speed * Time.deltaTime;
    }

    private void OnCollisionEnter(Collision collision) => HandleHit3D(collision.gameObject, collision.contacts[0].normal);
    private void OnCollisionEnter2D(Collision2D collision) => HandleHit2D(collision.gameObject, collision.contacts[0].normal);
    private void OnTriggerEnter(Collider other) => HandleHit3D(other.gameObject, -direction);
    private void OnTriggerEnter2D(Collider2D other) => HandleHit2D(other.gameObject, -direction);

    #endregion

    #region Internal

    private void ApplyHoming()
    {
        Vector3 toTarget = (homingTarget.position - transform.position).normalized;
        float angle = Vector3.Angle(direction, toTarget);
        if (angle <= maxHomingAngle)
        {
            direction = Vector3.Slerp(direction, toTarget, homingStrength * Time.deltaTime).normalized;
            transform.rotation = Quaternion.LookRotation(direction);

            if (movementType == MovementType.Rigidbody && rb != null)
                rb.linearVelocity = direction * speed;
            else if (movementType == MovementType.Rigidbody2D && rb2d != null)
                rb2d.linearVelocity = (Vector2)(direction * speed);
        }
    }

    private void HandleHit3D(GameObject hitObject, Vector3 normal) => HandleHit(hitObject, normal);
    private void HandleHit2D(GameObject hitObject, Vector2 normal) => HandleHit(hitObject, normal);

    private void HandleHit(GameObject hitObject, Vector3 normal)
    {
        if (!isLaunched) return;
        if (hitObject == owner) return;

        bool isTarget = string.IsNullOrEmpty(targetTag) || hitObject.CompareTag(targetTag);
        if (!isTarget) return;

        // Spawn hit effect
        if (hitEffect != null)
        {
            var fx = Instantiate(hitEffect, transform.position, Quaternion.LookRotation(normal));
            Destroy(fx, effectDuration);
        }

        // Play hit sound
        if (hitSound != null)
            AudioSource.PlayClipAtPoint(hitSound, transform.position);

        OnHit?.Invoke(hitObject);

        // Handle bounce
        if (canBounce && bounceCount < maxBounces)
        {
            direction = Vector3.Reflect(direction, normal);
            speed *= bounciness;
            bounceCount++;
            OnBounce?.Invoke(normal);

            if (movementType == MovementType.Rigidbody && rb != null)
                rb.linearVelocity = direction * speed;
            else if (movementType == MovementType.Rigidbody2D && rb2d != null)
                rb2d.linearVelocity = (Vector2)(direction * speed);

            transform.rotation = Quaternion.LookRotation(direction);
            return;
        }

        // Handle pierce
        if (canPierce && pierceCount < maxPierceCount)
        {
            pierceCount++;
            currentDamage *= (1f - pierceDamageReduction);
            return;
        }

        DestroyProjectile();
    }

    #endregion
}
