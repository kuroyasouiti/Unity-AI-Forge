using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Game feel feedback system supporting hitstop, screen shake, flash,
/// scale punch, and other juice effects.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum FeedbackType
    {
        Hitstop,
        ScreenShake,
        Flash,
        ColorFlash,
        Scale,
        Position,
        Rotation,
        Sound,
        Particle,
        Haptic
    }

    [Serializable]
    public class FeedbackComponent
    {
        public FeedbackType type = FeedbackType.Hitstop;
        public float delay;
        public float duration = 0.1f;
        public float intensity = 1f;

        [Header("Hitstop")]
        public float hitstopTimeScale = 0.01f;

        [Header("Screen Shake")]
        public float shakeFrequency = 25f;
        public bool shakeX = true;
        public bool shakeY = true;
        public bool shakeZ;

        [Header("Flash")]
        public Color flashColor = Color.white;
        public float fadeTime = 0.05f;

        [Header("Scale")]
        public Vector3 scaleAmount = new Vector3(1.2f, 1.2f, 1.2f);
        public AnimationCurve scaleCurve = AnimationCurve.EaseInOut(0, 1, 1, 0);

        [Header("Position")]
        public Vector3 positionAmount = new Vector3(0.1f, 0, 0);

        [Header("Sound")]
        public AudioClip soundClip;
        public float soundVolume = 1f;

        [Header("Particle")]
        public GameObject particlePrefab;
        public Vector3 particleOffset;

        [Header("Haptic")]
        public float hapticIntensity = 0.5f;
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string feedbackId = "{{FEEDBACK_ID}}";

    [Header("Settings")]
    [SerializeField] private List<FeedbackComponent> components = new List<FeedbackComponent>();
    [SerializeField] private bool playOnEnable = {{PLAY_ON_ENABLE}};
    [SerializeField] private float globalIntensityMultiplier = {{GLOBAL_INTENSITY}};

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent OnFeedbackStarted = new UnityEvent();
    public UnityEvent OnFeedbackCompleted = new UnityEvent();

    #endregion

    #region State

    private bool isPlaying;
    private readonly List<Coroutine> activeCoroutines = new List<Coroutine>();
    private Vector3 originalPosition;
    private Vector3 originalScale;

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var f) ? f : null;
    }

    public static void Play(string id)
    {
        var fb = FindById(id);
        if (fb != null) fb.PlayFeedback();
    }

    #endregion

    #region Properties

    public string FeedbackId => feedbackId;
    public bool IsPlaying => isPlaying;

    #endregion

    #region Lifecycle

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(feedbackId))
            _registry[feedbackId] = this;
        if (playOnEnable) PlayFeedback();
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(feedbackId))
            _registry.Remove(feedbackId);
        StopFeedback();
    }

    #endregion

    #region Public API

    public void PlayFeedback()
    {
        PlayFeedback(globalIntensityMultiplier);
    }

    public void PlayFeedback(float intensityMultiplier)
    {
        StopFeedback();
        isPlaying = true;
        originalPosition = transform.localPosition;
        originalScale = transform.localScale;
        OnFeedbackStarted?.Invoke();

        foreach (var comp in components)
            activeCoroutines.Add(StartCoroutine(PlayComponent(comp, intensityMultiplier)));
    }

    public void StopFeedback()
    {
        foreach (var co in activeCoroutines)
        {
            if (co != null) StopCoroutine(co);
        }
        activeCoroutines.Clear();
        isPlaying = false;

        transform.localPosition = originalPosition;
        transform.localScale = originalScale;
        Time.timeScale = 1f;
    }

    public void AddComponent(FeedbackComponent component)
    {
        if (component != null) components.Add(component);
    }

    public void ClearComponents()
    {
        components.Clear();
    }

    public void SetIntensity(float intensity)
    {
        globalIntensityMultiplier = intensity;
    }

    #endregion

    #region Internal

    private IEnumerator PlayComponent(FeedbackComponent comp, float intensityMul)
    {
        if (comp.delay > 0) yield return new WaitForSecondsRealtime(comp.delay);

        float intensity = comp.intensity * intensityMul;

        switch (comp.type)
        {
            case FeedbackType.Hitstop:
                yield return PlayHitstop(comp, intensity);
                break;
            case FeedbackType.ScreenShake:
                yield return PlayScreenShake(comp, intensity);
                break;
            case FeedbackType.Flash:
            case FeedbackType.ColorFlash:
                yield return PlayFlash(comp, intensity);
                break;
            case FeedbackType.Scale:
                yield return PlayScale(comp, intensity);
                break;
            case FeedbackType.Position:
                yield return PlayPosition(comp, intensity);
                break;
            case FeedbackType.Sound:
                PlaySound(comp, intensity);
                break;
            case FeedbackType.Particle:
                PlayParticle(comp);
                break;
        }

        // Check if all coroutines are done
        activeCoroutines.RemoveAll(c => c == null);
        if (activeCoroutines.Count <= 1)
        {
            isPlaying = false;
            OnFeedbackCompleted?.Invoke();
        }
    }

    private IEnumerator PlayHitstop(FeedbackComponent comp, float intensity)
    {
        Time.timeScale = comp.hitstopTimeScale;
        yield return new WaitForSecondsRealtime(comp.duration * intensity);
        Time.timeScale = 1f;
    }

    private IEnumerator PlayScreenShake(FeedbackComponent comp, float intensity)
    {
        var cam = Camera.main;
        if (cam == null) yield break;

        var camTransform = cam.transform;
        var origPos = camTransform.localPosition;
        float elapsed = 0;

        while (elapsed < comp.duration)
        {
            float t = elapsed / comp.duration;
            float dampedIntensity = intensity * (1f - t);
            float x = comp.shakeX ? UnityEngine.Random.Range(-1f, 1f) * dampedIntensity : 0;
            float y = comp.shakeY ? UnityEngine.Random.Range(-1f, 1f) * dampedIntensity : 0;
            float z = comp.shakeZ ? UnityEngine.Random.Range(-1f, 1f) * dampedIntensity : 0;

            camTransform.localPosition = origPos + new Vector3(x, y, z);
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }

        camTransform.localPosition = origPos;
    }

    private IEnumerator PlayFlash(FeedbackComponent comp, float intensity)
    {
        var renderer = GetComponent<SpriteRenderer>();
        if (renderer == null) renderer = GetComponentInChildren<SpriteRenderer>();
        if (renderer == null) yield break;

        var origColor = renderer.color;
        renderer.color = Color.Lerp(origColor, comp.flashColor, intensity);

        yield return new WaitForSecondsRealtime(comp.duration);

        float elapsed = 0;
        while (elapsed < comp.fadeTime)
        {
            float t = elapsed / comp.fadeTime;
            renderer.color = Color.Lerp(comp.flashColor, origColor, t);
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
        renderer.color = origColor;
    }

    private IEnumerator PlayScale(FeedbackComponent comp, float intensity)
    {
        float elapsed = 0;
        while (elapsed < comp.duration)
        {
            float t = elapsed / comp.duration;
            float curveValue = comp.scaleCurve.Evaluate(t);
            Vector3 scale = Vector3.Lerp(originalScale, Vector3.Scale(originalScale, comp.scaleAmount), curveValue * intensity);
            transform.localScale = scale;
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
        transform.localScale = originalScale;
    }

    private IEnumerator PlayPosition(FeedbackComponent comp, float intensity)
    {
        float elapsed = 0;
        while (elapsed < comp.duration)
        {
            float t = elapsed / comp.duration;
            float shake = Mathf.Sin(t * Mathf.PI * 2f * 4f) * (1f - t);
            transform.localPosition = originalPosition + comp.positionAmount * shake * intensity;
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
        transform.localPosition = originalPosition;
    }

    private void PlaySound(FeedbackComponent comp, float intensity)
    {
        if (comp.soundClip == null) return;
        var source = GetComponent<AudioSource>();
        if (source == null) source = gameObject.AddComponent<AudioSource>();
        source.PlayOneShot(comp.soundClip, comp.soundVolume * intensity);
    }

    private void PlayParticle(FeedbackComponent comp)
    {
        if (comp.particlePrefab == null) return;
        var instance = Instantiate(comp.particlePrefab, transform.position + comp.particleOffset, Quaternion.identity);
        var ps = instance.GetComponent<ParticleSystem>();
        if (ps != null)
        {
            var main = ps.main;
            Destroy(instance, main.duration + main.startLifetime.constantMax);
        }
        else
        {
            Destroy(instance, 5f);
        }
    }

    #endregion
}
