using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

/// <summary>
/// Centralized effect manager for camera shake, screen flash, time scale, and one-shot audio.
/// Singleton pattern with DontDestroyOnLoad support.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum EffectType
    {
        Particle,
        Sound,
        CameraShake,
        ScreenFlash,
        TimeScale
    }

    [Serializable]
    public class EffectEntry
    {
        public string effectId;
        public EffectType type;
        public GameObject prefab;
        public AudioClip audioClip;
        public float intensity = 1f;
        public float duration = 0.5f;
        public Color color = Color.white;
    }

    #endregion

    #region Settings

    [Header("Settings")]
    [SerializeField] private bool persistent = {{PERSISTENT}};
    [SerializeField] private Camera mainCamera;

    [Header("Effects")]
    [SerializeField] private List<EffectEntry> registeredEffects = new List<EffectEntry>();

    [Header("Audio Pool")]
    [SerializeField] private int audioSourcePoolSize = {{AUDIO_POOL_SIZE}};

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<string> OnEffectPlayed = new UnityEvent<string>();
    public UnityEvent<string> OnEffectEnded = new UnityEvent<string>();

    #endregion

    #region Singleton

    private static {{CLASS_NAME}} _instance;

    public static {{CLASS_NAME}} Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = FindFirstObjectByType<{{CLASS_NAME}}>();
                if (_instance == null)
                {
                    var go = new GameObject("{{CLASS_NAME}}");
                    _instance = go.AddComponent<{{CLASS_NAME}}>();
                }
            }
            return _instance;
        }
    }

    #endregion

    #region State

    private readonly Dictionary<string, EffectEntry> effectLookup = new Dictionary<string, EffectEntry>();
    private readonly List<AudioSource> audioSourcePool = new List<AudioSource>();
    private int currentAudioIndex;
    private Canvas screenFlashCanvas;
    private Image screenFlashImage;
    private Vector3 originalCameraPosition;
    private Coroutine cameraShakeCoroutine;
    private Coroutine screenFlashCoroutine;
    private Coroutine timeScaleCoroutine;
    private bool isShaking;

    #endregion

    #region Lifecycle

    private void Awake()
    {
        if (_instance != null && _instance != this)
        {
            Destroy(gameObject);
            return;
        }
        _instance = this;

        if (persistent)
            DontDestroyOnLoad(gameObject);

        InitializeLookup();
        InitializeAudioPool();
    }

    private void OnDestroy()
    {
        if (_instance == this)
            _instance = null;
    }

    #endregion

    #region Public API

    public void RegisterEffect(EffectEntry entry)
    {
        if (entry == null || string.IsNullOrEmpty(entry.effectId)) return;
        effectLookup[entry.effectId] = entry;
        registeredEffects.Add(entry);
    }

    public void UnregisterEffect(string effectId)
    {
        if (effectLookup.Remove(effectId))
            registeredEffects.RemoveAll(e => e.effectId == effectId);
    }

    public void PlayEffect(string effectId, Vector3 position)
    {
        if (!effectLookup.TryGetValue(effectId, out var entry)) return;
        PlayEffect(entry, position);
    }

    public void PlayEffect(EffectEntry entry, Vector3 position)
    {
        if (entry == null) return;

        switch (entry.type)
        {
            case EffectType.Particle:
                if (entry.prefab != null)
                {
                    var instance = Instantiate(entry.prefab, position, Quaternion.identity);
                    Destroy(instance, entry.duration > 0 ? entry.duration : 5f);
                }
                break;
            case EffectType.Sound:
                if (entry.audioClip != null)
                    PlayOneShot(entry.audioClip, position, entry.intensity);
                break;
            case EffectType.CameraShake:
                ShakeCamera(entry.intensity, entry.duration);
                break;
            case EffectType.ScreenFlash:
                FlashScreen(entry.color, entry.duration);
                break;
            case EffectType.TimeScale:
                SetTimeScale(entry.intensity, entry.duration);
                break;
        }

        OnEffectPlayed?.Invoke(entry.effectId);
    }

    public void PlayOneShot(AudioClip clip, Vector3 position, float vol = 1f)
    {
        if (clip == null) return;
        var source = GetPooledAudioSource();
        source.transform.position = position;
        source.PlayOneShot(clip, vol);
    }

    public void ShakeCamera(float intensity, float duration, float frequency = 25f)
    {
        if (cameraShakeCoroutine != null) StopCoroutine(cameraShakeCoroutine);
        cameraShakeCoroutine = StartCoroutine(ShakeCameraCoroutine(intensity, duration, frequency));
    }

    public void FlashScreen(Color color, float duration, float fadeTime = 0.1f)
    {
        EnsureFlashCanvas();
        if (screenFlashCoroutine != null) StopCoroutine(screenFlashCoroutine);
        screenFlashCoroutine = StartCoroutine(FlashScreenCoroutine(color, duration, fadeTime));
    }

    public void SetTimeScale(float targetScale, float duration, float transitionTime = 0.05f)
    {
        if (timeScaleCoroutine != null) StopCoroutine(timeScaleCoroutine);
        timeScaleCoroutine = StartCoroutine(TimeScaleCoroutine(targetScale, duration, transitionTime));
    }

    public bool HasEffect(string effectId) => effectLookup.ContainsKey(effectId);

    public IEnumerable<string> GetRegisteredEffectIds() => effectLookup.Keys;

    #endregion

    #region Internal

    private void InitializeLookup()
    {
        effectLookup.Clear();
        foreach (var entry in registeredEffects)
        {
            if (!string.IsNullOrEmpty(entry.effectId))
                effectLookup[entry.effectId] = entry;
        }
    }

    private void InitializeAudioPool()
    {
        for (int i = 0; i < audioSourcePoolSize; i++)
        {
            var source = gameObject.AddComponent<AudioSource>();
            source.playOnAwake = false;
            audioSourcePool.Add(source);
        }
    }

    private AudioSource GetPooledAudioSource()
    {
        if (audioSourcePool.Count == 0)
        {
            var source = gameObject.AddComponent<AudioSource>();
            source.playOnAwake = false;
            audioSourcePool.Add(source);
            return source;
        }

        var pooled = audioSourcePool[currentAudioIndex % audioSourcePool.Count];
        currentAudioIndex++;
        return pooled;
    }

    private Camera GetCamera()
    {
        if (mainCamera == null) mainCamera = Camera.main;
        return mainCamera;
    }

    private IEnumerator ShakeCameraCoroutine(float intensity, float duration, float frequency)
    {
        var cam = GetCamera();
        if (cam == null) yield break;

        var camTransform = cam.transform;
        originalCameraPosition = camTransform.localPosition;
        isShaking = true;
        float elapsed = 0;

        while (elapsed < duration)
        {
            float damped = intensity * (1f - (elapsed / duration));
            float x = Mathf.PerlinNoise(Time.time * frequency, 0) * 2f - 1f;
            float y = Mathf.PerlinNoise(0, Time.time * frequency) * 2f - 1f;
            camTransform.localPosition = originalCameraPosition + new Vector3(x, y, 0) * damped;
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }

        camTransform.localPosition = originalCameraPosition;
        isShaking = false;
    }

    private void EnsureFlashCanvas()
    {
        if (screenFlashCanvas != null) return;

        var canvasGo = new GameObject("ScreenFlashCanvas");
        canvasGo.transform.SetParent(transform);
        screenFlashCanvas = canvasGo.AddComponent<Canvas>();
        screenFlashCanvas.renderMode = RenderMode.ScreenSpaceOverlay;
        screenFlashCanvas.sortingOrder = 9999;

        var imageGo = new GameObject("FlashImage");
        imageGo.transform.SetParent(canvasGo.transform);
        screenFlashImage = imageGo.AddComponent<Image>();
        var rt = screenFlashImage.rectTransform;
        rt.anchorMin = Vector2.zero;
        rt.anchorMax = Vector2.one;
        rt.offsetMin = Vector2.zero;
        rt.offsetMax = Vector2.zero;
        screenFlashImage.color = new Color(1, 1, 1, 0);
        screenFlashImage.raycastTarget = false;
    }

    private IEnumerator FlashScreenCoroutine(Color color, float duration, float fadeTime)
    {
        screenFlashImage.color = color;
        yield return new WaitForSecondsRealtime(duration);

        float elapsed = 0;
        while (elapsed < fadeTime)
        {
            float t = elapsed / fadeTime;
            screenFlashImage.color = Color.Lerp(color, new Color(color.r, color.g, color.b, 0), t);
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
        screenFlashImage.color = new Color(1, 1, 1, 0);
    }

    private IEnumerator TimeScaleCoroutine(float targetScale, float duration, float transitionTime)
    {
        float originalScale = Time.timeScale;

        // Transition to target
        float elapsed = 0;
        while (elapsed < transitionTime)
        {
            Time.timeScale = Mathf.Lerp(originalScale, targetScale, elapsed / transitionTime);
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
        Time.timeScale = targetScale;

        yield return new WaitForSecondsRealtime(duration);

        // Transition back
        elapsed = 0;
        while (elapsed < transitionTime)
        {
            Time.timeScale = Mathf.Lerp(targetScale, 1f, elapsed / transitionTime);
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }
        Time.timeScale = 1f;
    }

    #endregion
}
