using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Visual effects wrapper with object pooling and lifecycle management.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Settings

    [Header("Identity")]
    [SerializeField] private string vfxId = "{{VFX_ID}}";

    [Header("Particle")]
    [SerializeField] private ParticleSystem particleSystem;
    [SerializeField] private GameObject particlePrefab;

    [Header("Playback")]
    [SerializeField] private bool autoPlay = {{AUTO_PLAY}};
    [SerializeField] private bool loop = {{LOOP}};

    [Header("Pooling")]
    [SerializeField] private bool usePooling = {{USE_POOLING}};
    [SerializeField] private int poolSize = {{POOL_SIZE}};
    [SerializeField] private bool attachToParent = {{ATTACH_TO_PARENT}};

    [Header("Multipliers")]
    [SerializeField] private float durationMultiplier = {{DURATION_MULTIPLIER}};
    [SerializeField] private float sizeMultiplier = {{SIZE_MULTIPLIER}};
    [SerializeField] private float emissionMultiplier = {{EMISSION_MULTIPLIER}};

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent OnVFXStarted = new UnityEvent();
    public UnityEvent OnVFXStopped = new UnityEvent();

    #endregion

    #region State

    private readonly Queue<GameObject> pool = new Queue<GameObject>();
    private readonly List<GameObject> activeInstances = new List<GameObject>();
    private bool isPlaying;

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var v) ? v : null;
    }

    public static void Play(string id, Vector3 position)
    {
        var vfx = FindById(id);
        if (vfx != null) vfx.PlayAt(position);
    }

    #endregion

    #region Properties

    public string VfxId => vfxId;
    public bool IsPlaying => isPlaying;

    #endregion

    #region Lifecycle

    private void Awake()
    {
        if (particleSystem == null)
            particleSystem = GetComponent<ParticleSystem>();
        if (usePooling && particlePrefab != null)
            InitializePool();
    }

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(vfxId))
            _registry[vfxId] = this;
        if (autoPlay) PlayVFX();
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(vfxId))
            _registry.Remove(vfxId);
    }

    private void OnDestroy()
    {
        ClearPool();
    }

    #endregion

    #region Public API

    public void PlayVFX()
    {
        if (particleSystem != null)
        {
            ApplyMultipliers(particleSystem);
            particleSystem.Play();
            isPlaying = true;
            OnVFXStarted?.Invoke();
        }
        else if (particlePrefab != null)
        {
            PlayAt(transform.position);
        }
    }

    public void PlayAt(Vector3 position)
    {
        PlayAt(position, Quaternion.identity);
    }

    public void PlayAt(Vector3 position, Quaternion rotation)
    {
        isPlaying = true;
        OnVFXStarted?.Invoke();

        if (particlePrefab != null)
        {
            var instance = GetFromPool();
            instance.transform.position = position;
            instance.transform.rotation = rotation;
            instance.SetActive(true);

            var ps = instance.GetComponent<ParticleSystem>();
            if (ps != null)
            {
                ApplyMultipliers(ps);
                ps.Play();
                StartCoroutine(ReturnToPoolAfterDone(instance, ps));
            }
        }
        else if (particleSystem != null)
        {
            transform.position = position;
            transform.rotation = rotation;
            particleSystem.Play();
        }
    }

    public void PlayAttached(Transform parent)
    {
        if (particlePrefab != null)
        {
            var instance = GetFromPool();
            instance.transform.SetParent(parent);
            instance.transform.localPosition = Vector3.zero;
            instance.transform.localRotation = Quaternion.identity;
            instance.SetActive(true);

            var ps = instance.GetComponent<ParticleSystem>();
            if (ps != null)
            {
                ApplyMultipliers(ps);
                ps.Play();
                StartCoroutine(ReturnToPoolAfterDone(instance, ps));
            }
        }
    }

    public void StopVFX()
    {
        if (particleSystem != null)
            particleSystem.Stop();
        isPlaying = false;
        OnVFXStopped?.Invoke();
    }

    public void StopImmediate()
    {
        if (particleSystem != null)
            particleSystem.Stop(true, ParticleSystemStopBehavior.StopEmittingAndClear);
        isPlaying = false;
        OnVFXStopped?.Invoke();
    }

    public void SetDurationMultiplier(float multiplier) => durationMultiplier = multiplier;
    public void SetSizeMultiplier(float multiplier) => sizeMultiplier = multiplier;
    public void SetEmissionMultiplier(float multiplier) => emissionMultiplier = multiplier;

    public void SetColor(Color color)
    {
        if (particleSystem != null)
        {
            var main = particleSystem.main;
            main.startColor = color;
        }
    }

    public void SetLoop(bool shouldLoop)
    {
        loop = shouldLoop;
        if (particleSystem != null)
        {
            var main = particleSystem.main;
            main.loop = shouldLoop;
        }
    }

    #endregion

    #region Internal

    private void InitializePool()
    {
        for (int i = 0; i < poolSize; i++)
        {
            var instance = Instantiate(particlePrefab, transform);
            instance.SetActive(false);
            pool.Enqueue(instance);
        }
    }

    private void ClearPool()
    {
        while (pool.Count > 0)
        {
            var obj = pool.Dequeue();
            if (obj != null) Destroy(obj);
        }
        foreach (var obj in activeInstances)
        {
            if (obj != null) Destroy(obj);
        }
        activeInstances.Clear();
    }

    private GameObject GetFromPool()
    {
        GameObject instance;
        if (usePooling && pool.Count > 0)
        {
            instance = pool.Dequeue();
        }
        else
        {
            instance = Instantiate(particlePrefab, attachToParent ? transform : null);
        }
        activeInstances.Add(instance);
        return instance;
    }

    private void ReturnToPool(GameObject instance)
    {
        if (instance == null) return;
        activeInstances.Remove(instance);
        instance.SetActive(false);

        if (usePooling)
        {
            if (!attachToParent) instance.transform.SetParent(transform);
            pool.Enqueue(instance);
        }
        else
        {
            Destroy(instance);
        }
    }

    private System.Collections.IEnumerator ReturnToPoolAfterDone(GameObject instance, ParticleSystem ps)
    {
        while (ps != null && ps.isPlaying)
            yield return null;
        ReturnToPool(instance);
        isPlaying = activeInstances.Count > 0;
        if (!isPlaying) OnVFXStopped?.Invoke();
    }

    private void ApplyMultipliers(ParticleSystem ps)
    {
        var main = ps.main;
        main.loop = loop;

        if (!Mathf.Approximately(sizeMultiplier, 1f))
            main.startSize = new ParticleSystem.MinMaxCurve(main.startSize.constant * sizeMultiplier);

        if (!Mathf.Approximately(emissionMultiplier, 1f))
        {
            var emission = ps.emission;
            emission.rateOverTime = new ParticleSystem.MinMaxCurve(emission.rateOverTime.constant * emissionMultiplier);
        }
    }

    #endregion
}
