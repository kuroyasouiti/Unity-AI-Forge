using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Animation state synchronization with game state.
/// Connects Animator parameters to game systems via rules.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum AnimParameterType
    {
        Float,
        Int,
        Bool
    }

    public enum SyncSourceType
    {
        Rigidbody3D,
        Rigidbody2D,
        Transform,
        Health,
        Custom
    }

    public enum TriggerEventSource
    {
        Health,
        Input,
        Manual
    }

    [Serializable]
    public class AnimSyncRule
    {
        public string parameterName;
        public AnimParameterType parameterType = AnimParameterType.Float;
        public SyncSourceType sourceType = SyncSourceType.Rigidbody2D;
        public string sourceProperty = "velocity.magnitude";
        public float multiplier = 1f;
        public float boolThreshold = 0.1f;
    }

    [Serializable]
    public class AnimTriggerRule
    {
        public string triggerName;
        public TriggerEventSource eventSource = TriggerEventSource.Manual;
        public string inputAction;
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string syncId = "{{SYNC_ID}}";

    [Header("Animator")]
    [SerializeField] private Animator animator;
    [SerializeField] private bool autoFindAnimator = {{AUTO_FIND_ANIMATOR}};

    [Header("Sync Rules")]
    [SerializeField] private List<AnimSyncRule> syncRules = new List<AnimSyncRule>();

    [Header("Trigger Rules")]
    [SerializeField] private List<AnimTriggerRule> triggerRules = new List<AnimTriggerRule>();

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<string, float> OnParameterSynced = new UnityEvent<string, float>();
    public UnityEvent<string> OnTriggerFired = new UnityEvent<string>();

    #endregion

    #region State

    private Rigidbody rb;
    private Rigidbody2D rb2d;
    private Vector3 lastPosition;
    private float calculatedSpeed;

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var s) ? s : null;
    }

    #endregion

    #region Properties

    public string SyncId => syncId;
    public Animator Animator => animator;

    #endregion

    #region Lifecycle

    private void Awake()
    {
        if (autoFindAnimator && animator == null)
            animator = GetComponent<Animator>() ?? GetComponentInChildren<Animator>();

        rb = GetComponent<Rigidbody>();
        rb2d = GetComponent<Rigidbody2D>();
        lastPosition = transform.position;
    }

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(syncId))
            _registry[syncId] = this;
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(syncId))
            _registry.Remove(syncId);
    }

    private void Update()
    {
        if (animator == null) return;

        // Calculate transform-based speed
        calculatedSpeed = (transform.position - lastPosition).magnitude / Time.deltaTime;
        lastPosition = transform.position;

        // Apply sync rules
        foreach (var rule in syncRules)
            ApplySyncRule(rule);
    }

    #endregion

    #region Public API

    public void AddSyncRule(AnimSyncRule rule)
    {
        if (rule != null) syncRules.Add(rule);
    }

    public bool RemoveSyncRule(string parameterName)
    {
        return syncRules.RemoveAll(r => r.parameterName == parameterName) > 0;
    }

    public void AddTriggerRule(AnimTriggerRule rule)
    {
        if (rule != null) triggerRules.Add(rule);
    }

    public bool RemoveTriggerRule(string triggerName)
    {
        return triggerRules.RemoveAll(r => r.triggerName == triggerName) > 0;
    }

    public void FireTrigger(string triggerName)
    {
        if (animator == null || string.IsNullOrEmpty(triggerName)) return;
        animator.SetTrigger(triggerName);
        OnTriggerFired?.Invoke(triggerName);
    }

    public void SetParameter(string parameterName, float value)
    {
        if (animator == null) return;
        animator.SetFloat(parameterName, value);
        OnParameterSynced?.Invoke(parameterName, value);
    }

    public void SetParameterBool(string parameterName, bool value)
    {
        if (animator == null) return;
        animator.SetBool(parameterName, value);
        OnParameterSynced?.Invoke(parameterName, value ? 1f : 0f);
    }

    public void SetParameterInt(string parameterName, int value)
    {
        if (animator == null) return;
        animator.SetInteger(parameterName, value);
        OnParameterSynced?.Invoke(parameterName, value);
    }

    #endregion

    #region Internal

    private void ApplySyncRule(AnimSyncRule rule)
    {
        if (string.IsNullOrEmpty(rule.parameterName)) return;

        float value = GetSourceValue(rule);
        value *= rule.multiplier;

        switch (rule.parameterType)
        {
            case AnimParameterType.Float:
                animator.SetFloat(rule.parameterName, value);
                break;
            case AnimParameterType.Int:
                animator.SetInteger(rule.parameterName, Mathf.RoundToInt(value));
                break;
            case AnimParameterType.Bool:
                animator.SetBool(rule.parameterName, Mathf.Abs(value) > rule.boolThreshold);
                break;
        }

        OnParameterSynced?.Invoke(rule.parameterName, value);
    }

    private float GetSourceValue(AnimSyncRule rule)
    {
        switch (rule.sourceType)
        {
            case SyncSourceType.Rigidbody3D:
                return GetRigidbody3DValue(rule.sourceProperty);
            case SyncSourceType.Rigidbody2D:
                return GetRigidbody2DValue(rule.sourceProperty);
            case SyncSourceType.Transform:
                return GetTransformValue(rule.sourceProperty);
            default:
                return 0f;
        }
    }

    private float GetRigidbody3DValue(string property)
    {
        if (rb == null) return 0f;
        return property switch
        {
            "velocity.magnitude" => rb.linearVelocity.magnitude,
            "velocity.x" => rb.linearVelocity.x,
            "velocity.y" => rb.linearVelocity.y,
            "velocity.z" => rb.linearVelocity.z,
            "angularVelocity.magnitude" => rb.angularVelocity.magnitude,
            _ => 0f
        };
    }

    private float GetRigidbody2DValue(string property)
    {
        if (rb2d == null) return 0f;
        return property switch
        {
            "velocity.magnitude" => rb2d.linearVelocity.magnitude,
            "velocity.x" => rb2d.linearVelocity.x,
            "velocity.y" => rb2d.linearVelocity.y,
            "angularVelocity" => rb2d.angularVelocity,
            _ => 0f
        };
    }

    private float GetTransformValue(string property)
    {
        return property switch
        {
            "speed" => calculatedSpeed,
            "position.x" => transform.position.x,
            "position.y" => transform.position.y,
            "position.z" => transform.position.z,
            "rotation.y" => transform.eulerAngles.y,
            _ => 0f
        };
    }

    #endregion
}
