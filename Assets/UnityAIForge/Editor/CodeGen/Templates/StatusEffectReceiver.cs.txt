using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Status effect (buff/debuff) receiver with stacking, ticks, and stat modifiers.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum EffectType { Buff, Debuff, Neutral }
    public enum StackBehavior { RefreshDuration, AddDuration, Independent, IncreaseStacks }

    [System.Serializable]
    public class EffectDefinition
    {
        public string effectId;
        public string displayName;
        public EffectType type;
        public float duration;
        public bool isPermanent;
        public bool stackable;
        public int maxStacks = 1;
        public StackBehavior stackBehavior;
        public float tickInterval;
        public float tickDamage;
        public float tickHeal;
        public string statName;
        public float statModifier;
    }

    [System.Serializable]
    public class ActiveEffect
    {
        public string effectId;
        public EffectDefinition definition;
        public int stacks = 1;
        public float remainingDuration;
        public float tickTimer;
        public GameObject source;
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string receiverId = "{{RECEIVER_ID}}";

    [Header("Immunity")]
    [SerializeField] private List<string> immuneEffects = new List<string>();

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<string, int> OnEffectApplied = new UnityEvent<string, int>();
    public UnityEvent<string> OnEffectRemoved = new UnityEvent<string>();
    public UnityEvent<string> OnEffectExpired = new UnityEvent<string>();
    public UnityEvent<string, int> OnEffectStackChanged = new UnityEvent<string, int>();
    public UnityEvent<string, float> OnEffectTick = new UnityEvent<string, float>();

    #endregion

    #region State

    private readonly List<ActiveEffect> activeEffects = new List<ActiveEffect>();
    private readonly Dictionary<string, float> statModifiers = new Dictionary<string, float>();

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    private static readonly Dictionary<string, EffectDefinition> _effectRegistry =
        new Dictionary<string, EffectDefinition>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var r) ? r : null;
    }

    public static void RegisterEffectDefinition(EffectDefinition def)
    {
        if (def != null && !string.IsNullOrEmpty(def.effectId))
            _effectRegistry[def.effectId] = def;
    }

    #endregion

    #region Properties

    public string ReceiverId => receiverId;
    public IReadOnlyList<ActiveEffect> ActiveEffects => activeEffects;

    #endregion

    #region Lifecycle

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(receiverId))
            _registry[receiverId] = this;
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(receiverId))
            _registry.Remove(receiverId);
    }

    private void Update()
    {
        float dt = Time.deltaTime;

        for (int i = activeEffects.Count - 1; i >= 0; i--)
        {
            var effect = activeEffects[i];

            if (!effect.definition.isPermanent)
            {
                effect.remainingDuration -= dt;
                if (effect.remainingDuration <= 0)
                {
                    RemoveEffectAt(i, expired: true);
                    continue;
                }
            }

            if (effect.definition.tickInterval > 0)
            {
                effect.tickTimer += dt;
                if (effect.tickTimer >= effect.definition.tickInterval)
                {
                    effect.tickTimer -= effect.definition.tickInterval;
                    ProcessTick(effect);
                }
            }
        }
    }

    #endregion

    #region Public API

    public bool ApplyEffect(EffectDefinition definition, GameObject source = null)
    {
        if (definition == null || string.IsNullOrEmpty(definition.effectId)) return false;
        if (immuneEffects.Contains(definition.effectId)) return false;

        var existing = activeEffects.Find(e => e.effectId == definition.effectId);

        if (existing != null && definition.stackable)
        {
            switch (definition.stackBehavior)
            {
                case StackBehavior.RefreshDuration:
                    existing.remainingDuration = definition.duration;
                    if (existing.stacks < definition.maxStacks)
                        existing.stacks++;
                    break;
                case StackBehavior.AddDuration:
                    existing.remainingDuration += definition.duration;
                    if (existing.stacks < definition.maxStacks)
                        existing.stacks++;
                    break;
                case StackBehavior.IncreaseStacks:
                    if (existing.stacks < definition.maxStacks)
                        existing.stacks++;
                    break;
                case StackBehavior.Independent:
                    AddNewEffect(definition, source);
                    break;
            }

            RecalculateStatModifiers();
            OnEffectStackChanged?.Invoke(definition.effectId, existing.stacks);
            return true;
        }

        if (existing != null && !definition.stackable)
        {
            existing.remainingDuration = definition.duration;
            return true;
        }

        AddNewEffect(definition, source);
        return true;
    }

    public bool ApplyEffect(string effectId, GameObject source = null)
    {
        if (_effectRegistry.TryGetValue(effectId, out var def))
            return ApplyEffect(def, source);
        return false;
    }

    public void RemoveEffect(string effectId)
    {
        for (int i = activeEffects.Count - 1; i >= 0; i--)
        {
            if (activeEffects[i].effectId == effectId)
            {
                RemoveEffectAt(i, expired: false);
                break;
            }
        }
    }

    public void RemoveEffectsOfType(EffectType type)
    {
        for (int i = activeEffects.Count - 1; i >= 0; i--)
        {
            if (activeEffects[i].definition.type == type)
                RemoveEffectAt(i, expired: false);
        }
    }

    public void ClearAllEffects()
    {
        for (int i = activeEffects.Count - 1; i >= 0; i--)
            RemoveEffectAt(i, expired: false);
    }

    public bool HasEffect(string effectId)
    {
        return activeEffects.Any(e => e.effectId == effectId);
    }

    public int GetStackCount(string effectId)
    {
        var effect = activeEffects.Find(e => e.effectId == effectId);
        return effect?.stacks ?? 0;
    }

    public float GetRemainingDuration(string effectId)
    {
        var effect = activeEffects.Find(e => e.effectId == effectId);
        return effect?.remainingDuration ?? 0f;
    }

    public float GetStatModifier(string statName)
    {
        return statModifiers.TryGetValue(statName, out var v) ? v : 0f;
    }

    #endregion

    #region Internal

    private void AddNewEffect(EffectDefinition definition, GameObject source)
    {
        var effect = new ActiveEffect
        {
            effectId = definition.effectId,
            definition = definition,
            stacks = 1,
            remainingDuration = definition.duration,
            tickTimer = 0,
            source = source
        };

        activeEffects.Add(effect);
        RecalculateStatModifiers();
        OnEffectApplied?.Invoke(definition.effectId, 1);
    }

    private void RemoveEffectAt(int index, bool expired)
    {
        var effect = activeEffects[index];
        activeEffects.RemoveAt(index);
        RecalculateStatModifiers();

        if (expired)
            OnEffectExpired?.Invoke(effect.effectId);
        else
            OnEffectRemoved?.Invoke(effect.effectId);
    }

    private void ProcessTick(ActiveEffect effect)
    {
        float tickValue = 0;

        if (effect.definition.tickDamage > 0)
        {
            float damage = effect.definition.tickDamage * effect.stacks;
            gameObject.SendMessage("TakeDamage", damage, SendMessageOptions.DontRequireReceiver);
            tickValue = damage;
        }

        if (effect.definition.tickHeal > 0)
        {
            float heal = effect.definition.tickHeal * effect.stacks;
            gameObject.SendMessage("Heal", heal, SendMessageOptions.DontRequireReceiver);
            tickValue = heal;
        }

        OnEffectTick?.Invoke(effect.effectId, tickValue);
    }

    private void RecalculateStatModifiers()
    {
        statModifiers.Clear();
        foreach (var effect in activeEffects)
        {
            if (string.IsNullOrEmpty(effect.definition.statName)) continue;
            float mod = effect.definition.statModifier * effect.stacks;
            if (statModifiers.ContainsKey(effect.definition.statName))
                statModifiers[effect.definition.statName] += mod;
            else
                statModifiers[effect.definition.statName] = mod;
        }
    }

    #endregion
}
