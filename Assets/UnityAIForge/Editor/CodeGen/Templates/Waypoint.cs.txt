using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Waypoint path follower for NPCs, platforms, and moving objects.
/// Supports transform, rigidbody, and rigidbody2d movement.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum PathMode
    {
        Once,
        Loop,
        PingPong
    }

    public enum MovementType
    {
        Transform,
        Rigidbody,
        Rigidbody2D
    }

    public enum RotationMode
    {
        None,
        LookAtTarget,
        AlignToPath
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string waypointId = "{{WAYPOINT_ID}}";

    [Header("Path")]
    [SerializeField] private List<Transform> waypoints = new List<Transform>();
    [SerializeField] private PathMode pathMode = PathMode.{{PATH_MODE}};
    [SerializeField] private bool autoStart = {{AUTO_START}};
    [SerializeField] private bool useLocalSpace = {{USE_LOCAL_SPACE}};

    [Header("Movement")]
    [SerializeField] private MovementType movementType = MovementType.{{MOVEMENT_TYPE}};
    [SerializeField] private float moveSpeed = {{MOVE_SPEED}};
    [SerializeField] private float rotationSpeed = {{ROTATION_SPEED}};
    [SerializeField] private RotationMode rotationMode = RotationMode.{{ROTATION_MODE}};

    [Header("Timing")]
    [SerializeField] private float waitTimeAtPoint = {{WAIT_TIME_AT_POINT}};
    [SerializeField] private List<float> waitTimesPerPoint = new List<float>();
    [SerializeField] private float startDelay = {{START_DELAY}};

    [Header("Smoothing")]
    [SerializeField] private bool smoothMovement = {{SMOOTH_MOVEMENT}};
    [SerializeField] private float smoothTime = {{SMOOTH_TIME}};
    [SerializeField] private float arrivalThreshold = {{ARRIVAL_THRESHOLD}};

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<int> OnReachWaypoint = new UnityEvent<int>();
    public UnityEvent OnPathComplete = new UnityEvent();
    public UnityEvent OnPathStart = new UnityEvent();
    public UnityEvent<int> OnDirectionChanged = new UnityEvent<int>();

    #endregion

    #region State

    private int currentIndex;
    private int direction = 1;
    private bool isMoving;
    private bool isPaused;
    private Rigidbody rb;
    private Rigidbody2D rb2d;
    private Vector3 smoothVelocity;

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var w) ? w : null;
    }

    #endregion

    #region Properties

    public string WaypointId => waypointId;
    public bool IsMoving => isMoving;
    public bool IsPaused => isPaused;
    public int CurrentIndex => currentIndex;
    public int WaypointCount => waypoints.Count;

    #endregion

    #region Lifecycle

    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
        rb2d = GetComponent<Rigidbody2D>();
    }

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(waypointId))
            _registry[waypointId] = this;
        if (autoStart && waypoints.Count > 0)
            StartPath();
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(waypointId))
            _registry.Remove(waypointId);
    }

    private void Update()
    {
        if (!isMoving || isPaused || waypoints.Count == 0) return;
        if (movementType != MovementType.Transform) return;

        MoveTowardsCurrent();
    }

    private void FixedUpdate()
    {
        if (!isMoving || isPaused || waypoints.Count == 0) return;
        if (movementType == MovementType.Transform) return;

        MoveTowardsCurrent();
    }

    #endregion

    #region Public API

    public void StartPath()
    {
        if (waypoints.Count == 0) return;
        if (startDelay > 0)
        {
            StartCoroutine(DelayedStart());
            return;
        }
        isMoving = true;
        isPaused = false;
        currentIndex = 0;
        direction = 1;
        OnPathStart?.Invoke();
    }

    public void StopPath()
    {
        isMoving = false;
        isPaused = false;
        StopAllCoroutines();
    }

    public void PausePath() { isPaused = true; }
    public void ResumePath() { isPaused = false; }

    public void ResetPath()
    {
        StopPath();
        currentIndex = 0;
        direction = 1;
        if (waypoints.Count > 0)
            transform.position = GetWaypointPosition(0);
    }

    public void GoToWaypoint(int index)
    {
        if (index < 0 || index >= waypoints.Count) return;
        currentIndex = index;
        isMoving = true;
        isPaused = false;
    }

    public void AddWaypoint(Vector3 position)
    {
        var wp = new GameObject($"WP_{waypoints.Count}");
        wp.transform.SetParent(transform.parent);
        wp.transform.position = position;
        waypoints.Add(wp.transform);
    }

    public void AddWaypoint(Transform waypointTransform)
    {
        if (waypointTransform != null)
            waypoints.Add(waypointTransform);
    }

    public void ClearWaypoints()
    {
        StopPath();
        waypoints.Clear();
    }

    public void SetWaypointPositions(List<Vector3> positions)
    {
        ClearWaypoints();
        if (positions == null) return;
        foreach (var pos in positions)
            AddWaypoint(pos);
    }

    #endregion

    #region Internal

    private IEnumerator DelayedStart()
    {
        yield return new WaitForSeconds(startDelay);
        isMoving = true;
        isPaused = false;
        currentIndex = 0;
        direction = 1;
        OnPathStart?.Invoke();
    }

    private void MoveTowardsCurrent()
    {
        if (currentIndex < 0 || currentIndex >= waypoints.Count) return;

        Vector3 target = GetWaypointPosition(currentIndex);
        Vector3 current = transform.position;
        float dist = Vector3.Distance(current, target);

        if (dist <= arrivalThreshold)
        {
            OnReachWaypoint?.Invoke(currentIndex);
            float waitTime = GetWaitTime(currentIndex);
            if (waitTime > 0)
            {
                StartCoroutine(WaitThenAdvance(waitTime));
                return;
            }
            AdvanceToNext();
            return;
        }

        // Move
        Vector3 dir = (target - current).normalized;

        if (smoothMovement)
        {
            Vector3 smoothed = Vector3.SmoothDamp(current, target, ref smoothVelocity, smoothTime, moveSpeed);
            ApplyMovement(smoothed);
        }
        else
        {
            Vector3 newPos = Vector3.MoveTowards(current, target, moveSpeed * Time.deltaTime);
            ApplyMovement(newPos);
        }

        // Rotate
        if (rotationMode == RotationMode.LookAtTarget && dir != Vector3.zero)
        {
            Quaternion targetRot = Quaternion.LookRotation(dir);
            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRot, rotationSpeed * Time.deltaTime);
        }
        else if (rotationMode == RotationMode.AlignToPath && dir != Vector3.zero)
        {
            float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
            transform.rotation = Quaternion.RotateTowards(transform.rotation, Quaternion.Euler(0, 0, angle), rotationSpeed * Time.deltaTime);
        }
    }

    private void ApplyMovement(Vector3 newPosition)
    {
        if (movementType == MovementType.Rigidbody && rb != null)
            rb.MovePosition(newPosition);
        else if (movementType == MovementType.Rigidbody2D && rb2d != null)
            rb2d.MovePosition(newPosition);
        else
            transform.position = newPosition;
    }

    private void AdvanceToNext()
    {
        int nextIndex = currentIndex + direction;

        switch (pathMode)
        {
            case PathMode.Once:
                if (nextIndex >= waypoints.Count)
                {
                    isMoving = false;
                    OnPathComplete?.Invoke();
                    return;
                }
                break;

            case PathMode.Loop:
                if (nextIndex >= waypoints.Count)
                    nextIndex = 0;
                break;

            case PathMode.PingPong:
                if (nextIndex >= waypoints.Count)
                {
                    direction = -1;
                    nextIndex = waypoints.Count - 2;
                    OnDirectionChanged?.Invoke(direction);
                }
                else if (nextIndex < 0)
                {
                    direction = 1;
                    nextIndex = 1;
                    OnDirectionChanged?.Invoke(direction);
                }
                break;
        }

        if (nextIndex >= 0 && nextIndex < waypoints.Count)
            currentIndex = nextIndex;
    }

    private IEnumerator WaitThenAdvance(float waitTime)
    {
        isMoving = false;
        yield return new WaitForSeconds(waitTime);
        isMoving = true;
        AdvanceToNext();
    }

    private Vector3 GetWaypointPosition(int index)
    {
        if (index < 0 || index >= waypoints.Count || waypoints[index] == null)
            return transform.position;
        return useLocalSpace ? waypoints[index].localPosition : waypoints[index].position;
    }

    private float GetWaitTime(int index)
    {
        if (waitTimesPerPoint != null && index < waitTimesPerPoint.Count)
            return waitTimesPerPoint[index];
        return waitTimeAtPoint;
    }

    #endregion

#if UNITY_EDITOR
    private void OnDrawGizmosSelected()
    {
        if (waypoints == null || waypoints.Count == 0) return;

        Gizmos.color = Color.cyan;
        for (int i = 0; i < waypoints.Count; i++)
        {
            if (waypoints[i] == null) continue;
            var pos = useLocalSpace ? waypoints[i].localPosition : waypoints[i].position;
            Gizmos.DrawWireSphere(pos, 0.3f);

            if (i < waypoints.Count - 1 && waypoints[i + 1] != null)
            {
                var next = useLocalSpace ? waypoints[i + 1].localPosition : waypoints[i + 1].position;
                Gizmos.DrawLine(pos, next);
            }
            else if (pathMode == PathMode.Loop && i == waypoints.Count - 1 && waypoints[0] != null)
            {
                var first = useLocalSpace ? waypoints[0].localPosition : waypoints[0].position;
                Gizmos.DrawLine(pos, first);
            }
        }
    }
#endif
}
