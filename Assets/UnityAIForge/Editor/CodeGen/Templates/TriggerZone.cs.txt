using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Trigger zone for damage, healing, teleport, checkpoints, and custom effects.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum ZoneType
    {
        Generic,
        Checkpoint,
        DamageZone,
        HealZone,
        Teleport,
        SpeedBoost,
        SlowDown,
        KillZone,
        SafeZone,
        Trigger
    }

    public enum TriggerMode
    {
        Once,
        OncePerEntity,
        Repeat,
        WhileInside
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string zoneId = "{{ZONE_ID}}";

    [Header("Zone Settings")]
    [SerializeField] private ZoneType zoneType = ZoneType.{{ZONE_TYPE}};
    [SerializeField] private TriggerMode triggerMode = TriggerMode.{{TRIGGER_MODE}};
    [SerializeField] private bool isActive = {{IS_ACTIVE}};

    [Header("Filtering")]
    [SerializeField] private string requiredTag = "{{REQUIRED_TAG}}";
    [SerializeField] private int maxTriggerCount = {{MAX_TRIGGER_COUNT}};

    [Header("Timing")]
    [SerializeField] private float cooldown = {{COOLDOWN}};
    [SerializeField] private float effectInterval = {{EFFECT_INTERVAL}};

    [Header("Effects")]
    [SerializeField] private float effectAmount = {{EFFECT_AMOUNT}};
    [SerializeField] private float speedMultiplier = {{SPEED_MULTIPLIER}};
    [SerializeField] private int checkpointIndex = {{CHECKPOINT_INDEX}};

    [Header("Teleport")]
    [SerializeField] private Transform teleportDestination;
    [SerializeField] private Vector3 teleportPosition = {{TELEPORT_POSITION}};
    [SerializeField] private string destinationPath = "{{DESTINATION_PATH}}";

    [Header("Gizmo")]
    [SerializeField] private Color gizmoColor = {{GIZMO_COLOR}};
    [SerializeField] private bool showGizmo = {{SHOW_GIZMO}};

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<GameObject> OnZoneEnter = new UnityEvent<GameObject>();
    public UnityEvent<GameObject> OnZoneExit = new UnityEvent<GameObject>();
    public UnityEvent<GameObject> OnZoneTriggered = new UnityEvent<GameObject>();
    public UnityEvent<GameObject, float> OnDamageApplied = new UnityEvent<GameObject, float>();
    public UnityEvent<GameObject, float> OnHealApplied = new UnityEvent<GameObject, float>();
    public UnityEvent<GameObject> OnTeleported = new UnityEvent<GameObject>();
    public UnityEvent<GameObject> OnCheckpointReached = new UnityEvent<GameObject>();

    #endregion

    #region State

    private int triggerCount;
    private float cooldownTimer;
    private readonly HashSet<int> triggeredEntities = new HashSet<int>();
    private readonly Dictionary<int, float> insideTimers = new Dictionary<int, float>();
    private readonly List<GameObject> entitiesInside = new List<GameObject>();

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var z) ? z : null;
    }

    #endregion

    #region Properties

    public string ZoneId => zoneId;
    public ZoneType Type => zoneType;
    public bool IsActive => isActive;
    public int TriggerCount => triggerCount;

    #endregion

    #region Lifecycle

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(zoneId))
            _registry[zoneId] = this;
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(zoneId))
            _registry.Remove(zoneId);
    }

    private void Update()
    {
        if (cooldownTimer > 0)
            cooldownTimer -= Time.deltaTime;

        if (triggerMode == TriggerMode.WhileInside && entitiesInside.Count > 0)
        {
            for (int i = entitiesInside.Count - 1; i >= 0; i--)
            {
                var entity = entitiesInside[i];
                if (entity == null)
                {
                    entitiesInside.RemoveAt(i);
                    continue;
                }

                int id = entity.GetInstanceID();
                if (!insideTimers.ContainsKey(id))
                    insideTimers[id] = 0;

                insideTimers[id] += Time.deltaTime;
                if (insideTimers[id] >= effectInterval)
                {
                    insideTimers[id] -= effectInterval;
                    ApplyEffect(entity);
                }
            }
        }
    }

    #endregion

    #region Trigger Callbacks

    private void OnTriggerEnter(Collider other)
    {
        HandleEnter(other.gameObject);
    }

    private void OnTriggerExit(Collider other)
    {
        HandleExit(other.gameObject);
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        HandleEnter(other.gameObject);
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        HandleExit(other.gameObject);
    }

    private void OnCollisionEnter(Collision collision)
    {
        HandleEnter(collision.gameObject);
    }

    private void OnCollisionEnter2D(Collision2D collision)
    {
        HandleEnter(collision.gameObject);
    }

    #endregion

    #region Public API

    public void Activate()
    {
        isActive = true;
    }

    public void Deactivate()
    {
        isActive = false;
    }

    public void ResetZone()
    {
        triggerCount = 0;
        cooldownTimer = 0;
        triggeredEntities.Clear();
        insideTimers.Clear();
        entitiesInside.Clear();
        isActive = true;
    }

    public void SetTeleportDestination(Vector3 position)
    {
        teleportPosition = position;
    }

    public void SetTeleportDestination(Transform target)
    {
        teleportDestination = target;
    }

    #endregion

    #region Internal

    private void HandleEnter(GameObject entity)
    {
        if (!isActive) return;
        if (!string.IsNullOrEmpty(requiredTag) && !entity.CompareTag(requiredTag)) return;
        if (maxTriggerCount > 0 && triggerCount >= maxTriggerCount) return;

        int entityId = entity.GetInstanceID();

        OnZoneEnter?.Invoke(entity);

        if (triggerMode == TriggerMode.WhileInside)
        {
            if (!entitiesInside.Contains(entity))
            {
                entitiesInside.Add(entity);
                insideTimers[entityId] = 0;
            }
            ApplyEffect(entity);
            return;
        }

        if (triggerMode == TriggerMode.OncePerEntity && triggeredEntities.Contains(entityId))
            return;

        if (triggerMode == TriggerMode.Repeat && cooldownTimer > 0)
            return;

        TriggerZoneEffect(entity);
    }

    private void HandleExit(GameObject entity)
    {
        entitiesInside.Remove(entity);
        insideTimers.Remove(entity.GetInstanceID());
        OnZoneExit?.Invoke(entity);
    }

    private void TriggerZoneEffect(GameObject entity)
    {
        triggerCount++;
        triggeredEntities.Add(entity.GetInstanceID());
        cooldownTimer = cooldown;

        OnZoneTriggered?.Invoke(entity);
        ApplyEffect(entity);

        if (triggerMode == TriggerMode.Once)
            isActive = false;
    }

    private void ApplyEffect(GameObject entity)
    {
        switch (zoneType)
        {
            case ZoneType.DamageZone:
                entity.SendMessage("TakeDamage", effectAmount, SendMessageOptions.DontRequireReceiver);
                OnDamageApplied?.Invoke(entity, effectAmount);
                break;

            case ZoneType.HealZone:
                entity.SendMessage("Heal", effectAmount, SendMessageOptions.DontRequireReceiver);
                OnHealApplied?.Invoke(entity, effectAmount);
                break;

            case ZoneType.KillZone:
                entity.SendMessage("Kill", SendMessageOptions.DontRequireReceiver);
                break;

            case ZoneType.Teleport:
                Vector3 dest = teleportDestination != null
                    ? teleportDestination.position
                    : teleportPosition;
                entity.transform.position = dest;
                OnTeleported?.Invoke(entity);
                break;

            case ZoneType.Checkpoint:
                entity.SendMessage("SetRespawnPosition", transform.position, SendMessageOptions.DontRequireReceiver);
                OnCheckpointReached?.Invoke(entity);
                break;

            case ZoneType.SpeedBoost:
            case ZoneType.SlowDown:
                entity.SendMessage("SetMoveSpeed",
                    speedMultiplier, SendMessageOptions.DontRequireReceiver);
                break;
        }
    }

    #endregion

#if UNITY_EDITOR
    private void OnDrawGizmos()
    {
        if (!showGizmo) return;
        Gizmos.color = gizmoColor;

        var boxCol = GetComponent<BoxCollider>();
        var sphereCol = GetComponent<SphereCollider>();
        var boxCol2D = GetComponent<BoxCollider2D>();
        var circleCol2D = GetComponent<CircleCollider2D>();

        if (boxCol != null)
            Gizmos.DrawWireCube(transform.position + boxCol.center, boxCol.size);
        else if (sphereCol != null)
            Gizmos.DrawWireSphere(transform.position + sphereCol.center, sphereCol.radius);
        else if (boxCol2D != null)
            Gizmos.DrawWireCube(transform.position + (Vector3)boxCol2D.offset, boxCol2D.size);
        else if (circleCol2D != null)
            Gizmos.DrawWireSphere(transform.position + (Vector3)circleCol2D.offset, circleCol2D.radius);
        else
            Gizmos.DrawWireSphere(transform.position, 1f);
    }
#endif
}
