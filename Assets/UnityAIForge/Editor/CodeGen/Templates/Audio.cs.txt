using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// Audio playback wrapper with fade controls, pitch variation, and spatial audio.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum AudioCategory
    {
        SFX,
        Music,
        Ambient,
        Voice,
        UI
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string audioId = "{{AUDIO_ID}}";

    [Header("Audio")]
    [SerializeField] private AudioSource audioSource;
    [SerializeField] private AudioClip audioClip;
    [SerializeField] private AudioCategory audioType = AudioCategory.{{AUDIO_TYPE}};

    [Header("Playback")]
    [SerializeField] private bool playOnEnable = {{PLAY_ON_ENABLE}};
    [SerializeField] private bool loop = {{LOOP}};
    [SerializeField] private float volume = {{VOLUME}};
    [SerializeField] private float pitch = {{PITCH}};
    [SerializeField] private float pitchVariation = {{PITCH_VARIATION}};

    [Header("Spatial")]
    [SerializeField] private float spatialBlend = {{SPATIAL_BLEND}};
    [SerializeField] private float minDistance = {{MIN_DISTANCE}};
    [SerializeField] private float maxDistance = {{MAX_DISTANCE}};

    [Header("Fade")]
    [SerializeField] private float fadeInDuration = {{FADE_IN_DURATION}};
    [SerializeField] private float fadeOutDuration = {{FADE_OUT_DURATION}};

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent OnAudioStarted = new UnityEvent();
    public UnityEvent OnAudioStopped = new UnityEvent();
    public UnityEvent OnAudioCompleted = new UnityEvent();

    #endregion

    #region State

    private Coroutine fadeCoroutine;
    private Coroutine completionCoroutine;
    private bool isPaused;

    #endregion

    #region Registry

    private static readonly Dictionary<string, {{CLASS_NAME}}> _registry =
        new Dictionary<string, {{CLASS_NAME}}>();

    public static {{CLASS_NAME}} FindById(string id)
    {
        return _registry.TryGetValue(id, out var a) ? a : null;
    }

    public static void Play(string id)
    {
        var audio = FindById(id);
        if (audio != null) audio.PlayAudio();
    }

    public static void Stop(string id, bool fade = true)
    {
        var audio = FindById(id);
        if (audio != null)
        {
            if (fade) audio.FadeOut();
            else audio.StopAudio();
        }
    }

    #endregion

    #region Properties

    public string AudioId => audioId;
    public AudioCategory Type => audioType;
    public bool IsPlaying => audioSource != null && audioSource.isPlaying;
    public bool IsPaused => isPaused;

    #endregion

    #region Lifecycle

    private void Awake()
    {
        if (audioSource == null)
            audioSource = GetComponent<AudioSource>();
        if (audioSource == null)
            audioSource = gameObject.AddComponent<AudioSource>();

        ConfigureAudioSource();
    }

    private void OnEnable()
    {
        if (!string.IsNullOrEmpty(audioId))
            _registry[audioId] = this;
        if (playOnEnable) PlayAudio();
    }

    private void OnDisable()
    {
        if (!string.IsNullOrEmpty(audioId))
            _registry.Remove(audioId);
    }

    #endregion

    #region Public API

    public void PlayAudio()
    {
        if (audioSource == null) return;
        ConfigureAudioSource();

        if (pitchVariation > 0)
            audioSource.pitch = pitch + Random.Range(-pitchVariation, pitchVariation);

        if (fadeInDuration > 0)
        {
            audioSource.volume = 0;
            audioSource.Play();
            FadeIn(fadeInDuration);
        }
        else
        {
            audioSource.Play();
        }

        isPaused = false;
        OnAudioStarted?.Invoke();

        if (!loop)
            completionCoroutine = StartCoroutine(WaitForCompletion());
    }

    public void PlayOneShot()
    {
        if (audioSource == null || audioClip == null) return;
        float p = pitch + (pitchVariation > 0 ? Random.Range(-pitchVariation, pitchVariation) : 0);
        audioSource.pitch = p;
        audioSource.PlayOneShot(audioClip, volume);
    }

    public void PlayAtPosition(Vector3 position)
    {
        if (audioClip == null) return;
        AudioSource.PlayClipAtPoint(audioClip, position, volume);
    }

    public void StopAudio()
    {
        if (fadeCoroutine != null) { StopCoroutine(fadeCoroutine); fadeCoroutine = null; }
        if (completionCoroutine != null) { StopCoroutine(completionCoroutine); completionCoroutine = null; }
        if (audioSource != null) audioSource.Stop();
        isPaused = false;
        OnAudioStopped?.Invoke();
    }

    public void PauseAudio()
    {
        if (audioSource != null && audioSource.isPlaying)
        {
            audioSource.Pause();
            isPaused = true;
        }
    }

    public void ResumeAudio()
    {
        if (audioSource != null && isPaused)
        {
            audioSource.UnPause();
            isPaused = false;
        }
    }

    public void FadeIn() => FadeIn(fadeInDuration > 0 ? fadeInDuration : 1f);

    public void FadeIn(float duration)
    {
        if (fadeCoroutine != null) StopCoroutine(fadeCoroutine);
        if (audioSource != null && !audioSource.isPlaying) audioSource.Play();
        fadeCoroutine = StartCoroutine(FadeVolume(0f, volume, duration));
    }

    public void FadeOut() => FadeOut(fadeOutDuration > 0 ? fadeOutDuration : 0.5f);

    public void FadeOut(float duration)
    {
        if (fadeCoroutine != null) StopCoroutine(fadeCoroutine);
        fadeCoroutine = StartCoroutine(FadeVolume(audioSource != null ? audioSource.volume : volume, 0f, duration, true));
    }

    public void CrossFadeTo(AudioClip newClip, float duration)
    {
        StartCoroutine(CrossFadeCoroutine(newClip, duration));
    }

    public void SetVolume(float newVolume)
    {
        volume = Mathf.Clamp01(newVolume);
        if (audioSource != null) audioSource.volume = volume;
    }

    public void SetPitch(float newPitch)
    {
        pitch = newPitch;
        if (audioSource != null) audioSource.pitch = pitch;
    }

    public void SetClip(AudioClip clip)
    {
        audioClip = clip;
        if (audioSource != null) audioSource.clip = clip;
    }

    public void SetLoop(bool shouldLoop)
    {
        loop = shouldLoop;
        if (audioSource != null) audioSource.loop = shouldLoop;
    }

    public float GetPlaybackTime() => audioSource != null ? audioSource.time : 0f;
    public void SetPlaybackTime(float time) { if (audioSource != null) audioSource.time = time; }
    public float GetDuration() => audioClip != null ? audioClip.length : 0f;

    #endregion

    #region Internal

    private void ConfigureAudioSource()
    {
        if (audioSource == null) return;
        audioSource.clip = audioClip;
        audioSource.volume = volume;
        audioSource.pitch = pitch;
        audioSource.loop = loop;
        audioSource.spatialBlend = spatialBlend;
        audioSource.minDistance = minDistance;
        audioSource.maxDistance = maxDistance;
        audioSource.playOnAwake = false;
    }

    private IEnumerator FadeVolume(float from, float to, float duration, bool stopOnComplete = false)
    {
        float elapsed = 0;
        while (elapsed < duration)
        {
            elapsed += Time.unscaledDeltaTime;
            float t = Mathf.Clamp01(elapsed / duration);
            if (audioSource != null) audioSource.volume = Mathf.Lerp(from, to, t);
            yield return null;
        }
        if (audioSource != null) audioSource.volume = to;
        if (stopOnComplete) StopAudio();
        fadeCoroutine = null;
    }

    private IEnumerator CrossFadeCoroutine(AudioClip newClip, float duration)
    {
        float halfDuration = duration * 0.5f;
        yield return FadeVolume(volume, 0f, halfDuration);
        SetClip(newClip);
        audioSource.Play();
        yield return FadeVolume(0f, volume, halfDuration);
    }

    private IEnumerator WaitForCompletion()
    {
        while (audioSource != null && audioSource.isPlaying)
            yield return null;
        if (!isPaused) OnAudioCompleted?.Invoke();
        completionCoroutine = null;
    }

    #endregion
}
