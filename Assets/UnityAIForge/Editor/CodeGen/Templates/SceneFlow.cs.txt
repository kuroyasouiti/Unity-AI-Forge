using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

/// <summary>
/// Scene transition state machine with shared scenes and trigger-based flow.
/// Generated by Unity-AI-Forge.
/// </summary>
public class {{CLASS_NAME}} : MonoBehaviour
{
    #region Types

    public enum SceneLoadMode { Single, Additive }

    [System.Serializable]
    public class SceneDefinition
    {
        public string sceneName;
        public string scenePath;
        public SceneLoadMode loadMode = SceneLoadMode.Single;
        public List<SceneTransition> transitions = new List<SceneTransition>();
        public List<string> sharedScenePaths = new List<string>();
    }

    [System.Serializable]
    public class SceneTransition
    {
        public string trigger;
        public string toScene;
    }

    #endregion

    #region Settings

    [Header("Identity")]
    [SerializeField] private string flowId = "{{FLOW_ID}}";

    [Header("Scenes")]
    [SerializeField] private List<SceneDefinition> scenes = new List<SceneDefinition>();
    [SerializeField] private string currentSceneName;

    #endregion

    #region Events

    [Header("Events")]
    public UnityEvent<string, string> OnSceneTransition = new UnityEvent<string, string>();
    public UnityEvent<string> OnSceneLoaded = new UnityEvent<string>();
    public UnityEvent<string> OnSceneUnloaded = new UnityEvent<string>();

    #endregion

    #region State

    private static {{CLASS_NAME}} _instance;
    private bool isTransitioning;
    private readonly List<string> loadedSharedScenes = new List<string>();

    #endregion

    #region Properties

    public static {{CLASS_NAME}} Instance => _instance;
    public string FlowId => flowId;
    public string CurrentScene => currentSceneName;
    public bool IsTransitioning => isTransitioning;

    #endregion

    #region Lifecycle

    private void Awake()
    {
        if (_instance != null && _instance != this)
        {
            Destroy(gameObject);
            return;
        }
        _instance = this;
        DontDestroyOnLoad(gameObject);
    }

    private void OnDestroy()
    {
        if (_instance == this)
            _instance = null;
    }

    #endregion

    #region Public API

    public void AddScene(string sceneName, string scenePath, SceneLoadMode loadMode = SceneLoadMode.Single,
        string[] sharedScenes = null)
    {
        if (scenes.Exists(s => s.sceneName == sceneName)) return;
        var def = new SceneDefinition
        {
            sceneName = sceneName,
            scenePath = scenePath,
            loadMode = loadMode
        };
        if (sharedScenes != null)
            def.sharedScenePaths.AddRange(sharedScenes);
        scenes.Add(def);
    }

    public void RemoveScene(string sceneName)
    {
        scenes.RemoveAll(s => s.sceneName == sceneName);
    }

    public void AddTransition(string fromScene, string trigger, string toScene)
    {
        var scene = scenes.Find(s => s.sceneName == fromScene);
        if (scene == null) return;
        if (scene.transitions.Exists(t => t.trigger == trigger)) return;
        scene.transitions.Add(new SceneTransition { trigger = trigger, toScene = toScene });
    }

    public void RemoveTransition(string fromScene, string trigger)
    {
        var scene = scenes.Find(s => s.sceneName == fromScene);
        scene?.transitions.RemoveAll(t => t.trigger == trigger);
    }

    public void TriggerTransition(string trigger)
    {
        if (isTransitioning) return;

        var currentDef = scenes.Find(s => s.sceneName == currentSceneName);
        if (currentDef == null) return;

        var transition = currentDef.transitions.Find(t => t.trigger == trigger);
        if (transition == null) return;

        StartCoroutine(TransitionToScene(transition.toScene));
    }

    public void LoadScene(string sceneName)
    {
        if (isTransitioning) return;
        StartCoroutine(TransitionToScene(sceneName));
    }

    public List<string> GetAvailableTriggers()
    {
        var currentDef = scenes.Find(s => s.sceneName == currentSceneName);
        if (currentDef == null) return new List<string>();
        var result = new List<string>();
        foreach (var t in currentDef.transitions)
            result.Add(t.trigger);
        return result;
    }

    public List<string> GetSceneNames()
    {
        var result = new List<string>();
        foreach (var s in scenes)
            result.Add(s.sceneName);
        return result;
    }

    #endregion

    #region Internal

    private IEnumerator TransitionToScene(string targetSceneName)
    {
        isTransitioning = true;
        string fromScene = currentSceneName;

        var targetDef = scenes.Find(s => s.sceneName == targetSceneName);
        if (targetDef == null)
        {
            isTransitioning = false;
            yield break;
        }

        OnSceneTransition?.Invoke(fromScene, targetSceneName);

        // Unload shared scenes not needed by the target
        for (int i = loadedSharedScenes.Count - 1; i >= 0; i--)
        {
            if (!targetDef.sharedScenePaths.Contains(loadedSharedScenes[i]))
            {
                var scn = SceneManager.GetSceneByPath(loadedSharedScenes[i]);
                if (scn.isLoaded)
                {
                    yield return SceneManager.UnloadSceneAsync(scn);
                    OnSceneUnloaded?.Invoke(loadedSharedScenes[i]);
                }
                loadedSharedScenes.RemoveAt(i);
            }
        }

        // Load main scene
        if (targetDef.loadMode == SceneLoadMode.Single)
        {
            yield return SceneManager.LoadSceneAsync(targetDef.scenePath, LoadSceneMode.Single);
        }
        else
        {
            yield return SceneManager.LoadSceneAsync(targetDef.scenePath, LoadSceneMode.Additive);
        }

        // Load shared scenes
        foreach (var sharedPath in targetDef.sharedScenePaths)
        {
            if (!loadedSharedScenes.Contains(sharedPath))
            {
                yield return SceneManager.LoadSceneAsync(sharedPath, LoadSceneMode.Additive);
                loadedSharedScenes.Add(sharedPath);
                OnSceneLoaded?.Invoke(sharedPath);
            }
        }

        currentSceneName = targetSceneName;
        isTransitioning = false;
        OnSceneLoaded?.Invoke(targetSceneName);
    }

    #endregion
}
